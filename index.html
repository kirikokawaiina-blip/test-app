<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>trpg鯖 トークン | Cloudflare同期版 v14 (KV-poll)</title>
    <meta name="description" content="Cloudflare Workers + KV を使ったルーム同期（無料プラン対応）。"/>
    <style>body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans JP', sans-serif;
        background: #0b1220;
        color: #e5edf6
    }

    header {
        position: sticky;
        top: 0;
        background: #0b132a99;
        border-bottom: 1px solid #60efff22;
        backdrop-filter: blur(12px)
    }

    .nav {
        max-width: 1200px;
        margin: 0 auto;
        padding: 10px 14px;
        display: grid;
        grid-template-columns:1fr auto;
        gap: 10px;
        align-items: center
    }

    .chip {
        padding: 6px 10px;
        border: 1px solid #60efff33;
        border-radius: 999px;
        color: #94a3b8;
        font-size: 12px
    }

    .btn {
        appearance: none;
        border: 0;
        border-radius: 10px;
        background: linear-gradient(90deg, #15c7b6, #60efff);
        padding: 10px 12px;
        font-weight: 800;
        cursor: pointer
    }

    .btn.secondary {
        background: transparent;
        border: 1px solid #60efff55;
        color: #e5edf6
    }

    .grid {
        max-width: 1200px;
        margin: 16px auto 40px;
        padding: 0 14px;
        display: grid;
        grid-template-columns:330px 1fr 340px;
        gap: 14px
    }

    @media (max-width: 1100px) {
        .grid {
            grid-template-columns:1fr
        }
    }

    .card {
        background: #0f172acc;
        border: 1px solid #1f2a44;
        border-radius: 16px;
        box-shadow: 0 10px 35px #0007
    }

    .card .hd {
        padding: 10px;
        border-bottom: 1px solid #60efff22
    }

    .card .bd {
        padding: 12px
    }

    .tabbar {
        display: flex;
        gap: 6px;
        flex-wrap: wrap
    }

    .tab {
        padding: 6px 10px;
        border: 1px solid #60efff33;
        border-radius: 999px;
        cursor: pointer
    }

    .tab.active {
        background: #15c7b61a;
        border-color: #60efff66
    }

    .panel {
        border: 1px solid #60efff22;
        border-radius: 10px;
        padding: 10px;
        background: #0c1628bb
    }

    .table {
        width: 100%;
        display: block;
        border: 1px solid #60efff13;
        border-radius: 10px
    }

    .table table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        min-width: 760px
    }

    .table th, .table td {
        padding: 8px 10px;
        border-bottom: 1px solid #60efff10;
        white-space: nowrap
    }

    .pill {
        padding: 4px 8px;
        border: 1px solid #15c7b652;
        border-radius: 999px;
        background: #15c7b61a
    }

    .toast {
        position: fixed;
        right: 12px;
        bottom: 12px;
        display: grid;
        gap: 6px
    }</style>

  <style>
    :root{
      --bg:#0a1024; --bg2:#0d1430; --panel:#0e1836; --line:#60efff22;
      --text:#e6f3ff; --muted:#9fb3c8; --accent:#60efff; --accent2:#2f80ed;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font:14px/1.6 system-ui,Segoe UI,Roboto,Helvetica,Arial;
      color:var(--text); background:linear-gradient(180deg,#060c1a, var(--bg));
    }
    h1,h2,h3{margin:0 0 8px}
    a{color:var(--accent); text-decoration:none}
    .container{max-width:1200px; margin:20px auto; padding:0 16px}

    .card{
      background:var(--panel); 
      border:1px solid var(--line);
      border-radius:16px; 
      padding:16px; 
      box-shadow:0 10px 30px #0004;
    }
    .card .hd{
      display:flex; 
      align-items:center; 
      justify-content:space-between; 
      margin-bottom:12px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--line);
    }
    .card .hd h2, .card .hd h3{
      font-size:15px; 
      font-weight:600;
      margin: 0;
    }
    .card .bd {
      font-size: 13px;
      line-height: 1.5;
    }
    .tabbar{display:flex; gap:6px}
    .tabbar .tab{
      font-weight:700; padding:6px 10px; border-radius:999px; cursor:pointer;
      border:1px solid var(--line); background:transparent; color:var(--muted);
    }
    .tabbar .tab.active{background:linear-gradient(180deg,var(--accent) ,var(--accent2)); color:#00121a}

    .btn{
      display:inline-block; 
      padding: 8px 12px; 
      border-radius: 8px; 
      font-weight: 600; 
      font-size: 13px;
      line-height: 1.4;
      border:0; 
      cursor:pointer;
      background:linear-gradient(180deg,var(--accent),var(--accent2)); 
      color:#00121a;
      box-shadow:0 4px 12px #0bf5ff33; 
      transition: all .2s ease;
    }
    .btn:hover {
      transform: translateY(-1px);
      box-shadow:0 6px 16px #0bf5ff44;
    }
    .btn:active{transform:translateY(1px)}
    .btn.secondary{
      background:#1a2a55; color:var(--text); border:1px solid var(--line); box-shadow:none;
    }
    .btn:disabled,.btn.secondary:disabled{opacity:.5; cursor:not-allowed}

    input,select,textarea{
      width:100%; background:#0b1430; color:var(--text); border:1px solid var(--line);
      border-radius:10px; padding:9px 10px; outline:none;
    }
    input::placeholder,textarea::placeholder{color:#7f93ab}

    .grid{
      display:grid; 
      gap:16px;
      max-width: 1440px;
      margin: 0 auto;
    }
    .grid.cols-3{
      grid-template-columns: minmax(280px, 1.2fr) minmax(320px, 2fr) minmax(280px, 1.2fr);
    }
    @media (max-width:1200px) {
      .grid.cols-3{
        grid-template-columns: minmax(280px, 1fr) minmax(320px, 2fr);
      }
    }
    @media (max-width:900px){ 
      .grid.cols-3{
        grid-template-columns:1fr
      } 
    }

    .pill{
      display:inline-block; padding:4px 8px; border-radius:999px; font-weight:750;
      background:#091430; border:1px solid var(--line); color:var(--accent);
    }
    .chip{
      display:inline-block; padding:6px 10px; border-radius:999px; background:#0c1736;
      border:1px solid var(--line); color:var(--muted); font-weight:700;
    }

    table{width:100%; border-collapse:separate; border-spacing:0 8px}
    td,th{padding:8px 10px; text-align:left}
    thead th{color:var(--muted); font-weight:800}
    tbody tr{
      background:#0b1632; 
      border:1px solid var(--line);
      transition: all 0.2s ease;
    }
    tbody tr td:first-child{
      border-top-left-radius:12px; 
      border-bottom-left-radius:12px
    }
    tbody tr td:last-child{
      border-top-right-radius:12px; 
      border-bottom-right-radius:12px
    }
    
    /* Responsive tables */
    .table {
      overflow-x: auto;
      max-width: 100%;
      margin: 0 -16px;
      padding: 0 16px;
      scrollbar-width: thin;
      scrollbar-color: rgba(96,239,255,.2) transparent;
    }
    .table::-webkit-scrollbar {
      height: 6px;
    }
    .table::-webkit-scrollbar-track {
      background: transparent;
    }
    .table::-webkit-scrollbar-thumb {
      background-color: rgba(96,239,255,.2);
      border-radius: 3px;
    }
    
    @media (max-width: 768px) {
      table {
        font-size: 12px;
      }
      td, th {
        padding: 6px 8px;
      }
    }

    #toast{position:fixed; right:16px; bottom:16px; display:flex; flex-direction:column; gap:8px; z-index:9}
    .status{color:var(--muted); font-weight:700}
  </style>

<!-- UI refinements: top panel control, collapsible sync settings, subtle horizontal scrollbars -->
<style id="theme-refinement">
  /* Top panel background (visual only; does not alter layout flow) */
  body::before {
    content: "";
    position: fixed; inset: 0 0 auto 0; height: 56px;
    background: linear-gradient(180deg, rgba(9,14,30,.85), rgba(12,18,38,.5));
    border-bottom: 1px solid rgba(96,239,255,.12);
    pointer-events: none; z-index: 60;
  }

  /* Pin the Start/Stop button globally accessible */
  #btnConnect {
    position: fixed !important;
    top: 10px; right: 14px;
    z-index: 70;
    box-shadow: 0 10px 24px rgba(21,199,182,.35), inset 0 0 0 1px rgba(255,255,255,.18) !important;
  }

  /* Sync panel toggle styles */
  .panel:has(#syncUrl) {
    max-height: 0;
    padding: 0;
    border-width: 0;
    overflow: hidden;
    transition: max-height 0.25s ease, padding 0.25s ease, border-width 0.25s ease;
  }
  .panel:has(#syncUrl).expanded {
    max-height: 680px;
    padding: 10px;
    border-width: 1px;
  }
  #toggleSync {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 12px;
    border-radius: 8px;
    background: rgba(14,24,44,.5);
    border: 1px solid rgba(96,239,255,.22);
    color: var(--text);
    cursor: pointer;
    font-size: 13px;
    font-weight: 600;
    margin-bottom: 8px;
    transition: background-color 0.2s;
  }
  #toggleSync:hover {
    background: rgba(14,24,44,.8);
  }
  #toggleSync::before {
    content: "⚙️";
    font-size: 14px;
  }

  /* Hide the native horizontal scrollbars but keep scrolling */
  /* WebKit */
  *::-webkit-scrollbar:horizontal { height: 0 !important; }
  /* Firefox (only for common horizontal containers) */
  .table, .scroll-x, [data-scroll="x"] { scrollbar-width: none; }
  .table, .scroll-x, [data-scroll="x"] { -ms-overflow-style: none; }
  .table::-webkit-scrollbar, .scroll-x::-webkit-scrollbar, [data-scroll="x"]::-webkit-scrollbar { display: none; }

  /* Optional visual cue: subtle edge gradients on horizontal-overflow containers */
  .table, .scroll-x, [data-scroll="x"] {
    position: relative;
    background: rgba(13,22,40,.4);
    mask-image: linear-gradient(to right, transparent 0, black 10px, black calc(100% - 10px), transparent 100%);
  }

  /* Ensure main content doesn't sit under the fixed top panel */
  main, .container { padding-top: 56px !important; }
</style>

</head>
<body>
<header>
    <div class="nav">
        <div style="display:flex;gap:10px;align-items:center">
            <div style="width:28px;height:28px;border-radius:8px;background:conic-gradient(from 200deg,#15c7b6,#60efff)"></div>
            trpg鯖 トークン<span class="chip">ローカル保存 & ルーム同期（KV）</span></div>
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <div id="userBadge" class="chip">未ログイン</div>
            <div id="streakBadge" class="chip">🔥0</div>
            <div id="jackpotBadge" class="chip">JPOT: 0</div>
            <button class="btn" id="morningBtn">朝活</button>
            <button class="btn secondary" id="exportBtn">エクスポート</button>
            <label class="btn secondary">インポート<input id="importFile" type="file" accept="application/json"
                                                          style="display:none"/></label></div>
    </div>
</header>
<main>
    <div class="grid">
        <section class="card">
            <div class="hd"><h3>アカウント & 同期</h3></div>
            <div class="bd">
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px">
                    <div class="panel">
                        <div class="chip">総ユーザー</div>
                        <div id="kpiMembers" style="font-weight:800">0</div>
                    </div>
                    <div class="panel">
                        <div class="chip">総供給量</div>
                        <div id="kpiSupply" style="font-weight:800">0 coin</div>
                    </div>
                </div>
                <button id="toggleSync">同期設定を表示</button>
                <div class="panel" id="syncPanel">
                    <label>同期設定（HTTP API /state）</label>
                    <input id="syncUrl" type="text" placeholder="https://<your-worker>.workers.dev/state"
                           style="width:100%;margin:6px 0"/>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
                        <input id="syncRoom" type="text" placeholder="ルーム名（例：trpg）"/>
                        <input id="syncKey" type="text" placeholder="ルーム鍵（例：1）"/>
                    </div>
                    <div class="tabbar" style="margin-top:8px">
                        <button class="btn" id="btnConnect">開始/停止</button>
                        <button class="btn secondary" id="btnSyncNow">手動同期</button>
                        <span id="syncStatus" class="chip">停止中</span></div>
                    <div id="lastSyncChip" class="chip" style="margin-top:6px">最終同期：—</div>
                </div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px">
                    <div class="panel">
                        <label>ログイン</label>
                        <input id="loginName" type="text" placeholder="ユーザー名"/><input id="loginPass"
                                                                                           type="password"
                                                                                           placeholder="パスワード"/>
                        <div class="tabbar">
                            <button class="btn" id="loginBtn">ログイン</button>
                            <button class="btn secondary" id="logoutBtn">ログアウト</button>
                        </div>
                    </div>
                    <div class="panel">
                        <label>新規登録（初期 10,000 coin）</label>
                        <input id="regName" type="text" placeholder="ユーザー名"/><input id="regPass" type="password"
                                                                                         placeholder="パスワード"/>
                        <button class="btn" id="registerBtn">登録</button>
                    </div>
                </div>
                <div class="panel" style="margin-top:8px"><label>ウォレット一覧</label>
                    <div id="walletList" style="display:grid;gap:6px"></div>
                </div>
            </div>
        </section>
        <section class="card">
            <div class="hd"><h3>操作</h3>
                <div class="tabbar">
                    <div class="tab active" data-tab="transfer">送金</div>
                    <div class="tab" data-tab="market">マーケット</div>
                    <div class="tab" data-tab="myrights">自分の権利</div>
                    <div class="tab" data-tab="gamble">ギャンブル</div>
                </div>
            </div>
            <div class="bd">
                <div id="tab-transfer">
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
                        <div class="panel"><label>送信元（あなた）</label><input id="fromFixed" type="text" disabled
                                                                               placeholder="未ログイン"/></div>
                        <div class="panel"><label>送信先</label><select id="toSelect"></select></div>
                    </div>
                    <div style="display:grid;grid-template-columns:1fr 140px;gap:10px;margin-top:8px">
                        <div class="panel"><label>金額（coin）</label><input id="amountInput" type="number" min="1"
                                                                           step="1" placeholder="例）250"/></div>
                        <div class="panel"><label>&nbsp;</label>
                            <button class="btn" id="sendBtn">送信する</button>
                        </div>
                    </div>
                    <div class="panel" style="margin-top:8px"><label>メモ（任意）</label><input id="memoInput" type="text"
                                                                                              placeholder="例）ギルド賞金"/>
                    </div>
                </div>
                <div id="tab-market" style="display:none;max-width:100%;overflow-x:hidden">
                    <div class="tabbar" style="margin-bottom:6px">
                        <div class="tab active" data-sub="sell">出品する</div>
                        <div class="tab" data-sub="list">出品一覧</div>
                    </div>
                    <div id="market-sell" class="panel">
                        <label>権利の出品</label><input id="listTitle" type="text" placeholder="例）ゲームを一緒に遊ぶ"/><textarea
                            id="listDesc" rows="2" placeholder="説明（任意）"></textarea>
                        <div style="display:grid;grid-template-columns:1fr 1fr 140px;gap:8px">
                            <div><label>価格</label><input id="listPrice" type="number" min="1" step="1"/></div>
                            <div><label>在庫</label><input id="listQty" type="number" min="1" step="1"/></div>
                            <div style="display:flex;align-items:end">
                                <button class="btn" id="createListingBtn">出品する</button>
                            </div>
                        </div>
                    </div>
                    <div id="market-list" style="display:none">
                        <div class="table">
                            <table>
                                <thead>
                                <tr>
                                    <th>タイトル</th>
                                    <th>価格</th>
                                    <th>在庫</th>
                                    <th>出品者</th>
                                    <th>説明</th>
                                    <th>操作</th>
                                </tr>
                                </thead>
                                <tbody id="listingBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
                <div id="tab-myrights" style="display:none">
                    <div class="table">
                        <table>
                            <thead>
                            <tr>
                                <th>日付</th>
                                <th>タイトル</th>
                                <th>販売者</th>
                                <th>状態</th>
                                <th>操作</th>
                            </tr>
                            </thead>
                            <tbody id="rightsBody"></tbody>
                        </table>
                    </div>
                </div>
                <div id="tab-gamble" style="display:none">
                    <div class="panel"><label>TRPGジャックポット</label>
                        <div class="tabbar">
                            <div class="chip" id="jackpotChip">現在: 0 coin</div>
                        </div>
                    </div>
                    <div class="panel"><h4 style="margin:0">🎰 ルーレット（1回100 coin）</h4>
                        <p style="margin:0;color:#94a3b8;font-size:12px">期待値約70%。1%で全額ジャックポット。</p>
                        <div class="tabbar">
                            <button class="btn" id="rouletteBtn">回す</button>
                        </div>
                        <div id="rouletteResult" class="chip" style="margin-top:8px">結果: —</div>
                    </div>
                </div>
                <div class="toast" id="toast"></div>
            </div>
        </section>
        <section class="card">
            <div class="hd"><h3>履歴</h3>
                <div class="tabbar"><input id="searchInput" type="text" placeholder="検索：名前 / メモ / 権利"
                                           style="width:200px"/><select id="memberFilter">
                    <option value="">すべて</option>
                </select>
                    <div id="lastActivity" class="chip">最終更新：—</div>
                </div>
            </div>
            <div class="bd">
                <div class="table">
                    <table>
                        <thead>
                        <tr>
                            <th>日付</th>
                            <th>種別</th>
                            <th>送信元/販売者</th>
                            <th>送信先/購入者</th>
                            <th>メモ/権利</th>
                            <th style="text-align:right">金額</th>
                        </tr>
                        </thead>
                        <tbody id="historyBody"></tbody>
                    </table>
                </div>
            </div>
        </section>
    </div>
</main>

<script>
    (function () {
        const LS_KEY = 'trpg_token_state_v14_kv', INITIAL_BAL = 10000, JACKPOT_NAME = 'ジャックポット';
        let state = {
            users: [],
            txs: [],
            listings: [],
            rights: [],
            currentUserId: null,
            jackpotUserId: '',
            lastRealUserId: null,
            approval: {active: false, votes: {}},
            version: 14,
            vTick: 0
        };
        const els = {
            kpiMembers: document.getElementById('kpiMembers'),
            kpiSupply: document.getElementById('kpiSupply'),
            walletList: document.getElementById('walletList'),
            toSelect: document.getElementById('toSelect'),
            sendBtn: document.getElementById('sendBtn'),
            amountInput: document.getElementById('amountInput'),
            memoInput: document.getElementById('memoInput'),
            historyBody: document.getElementById('historyBody'),
            searchInput: document.getElementById('searchInput'),
            memberFilter: document.getElementById('memberFilter'),
            exportBtn: document.getElementById('exportBtn'),
            importFile: document.getElementById('importFile'),
            lastActivity: document.getElementById('lastActivity'),
            userBadge: document.getElementById('userBadge'),
            fromFixed: document.getElementById('fromFixed'),
            streakBadge: document.getElementById('streakBadge'),
            jackpotBadge: document.getElementById('jackpotBadge'),
            morningBtn: document.getElementById('morningBtn'),
            loginName: document.getElementById('loginName'),
            loginPass: document.getElementById('loginPass'),
            loginBtn: document.getElementById('loginBtn'),
            logoutBtn: document.getElementById('logoutBtn'),
            regName: document.getElementById('regName'),
            regPass: document.getElementById('regPass'),
            registerBtn: document.getElementById('registerBtn'),
            tabs: Array.from(document.querySelectorAll('.tabbar .tab')),
            tabTransfer: document.getElementById('tab-transfer'),
            tabMarket: document.getElementById('tab-market'),
            tabMyRights: document.getElementById('tab-myrights'),
            tabGamble: document.getElementById('tab-gamble'),
            listTitle: document.getElementById('listTitle'),
            listDesc: document.getElementById('listDesc'),
            listPrice: document.getElementById('listPrice'),
            listQty: document.getElementById('listQty'),
            createListingBtn: document.getElementById('createListingBtn'),
            listingBody: document.getElementById('listingBody'),
            rightsBody: document.getElementById('rightsBody'),
            subtabs: Array.from(document.querySelectorAll('#tab-market .tab')),
            marketSell: document.getElementById('market-sell'),
            marketList: document.getElementById('market-list'),
            jackpotChip: document.getElementById('jackpotChip'),
            rouletteBtn: document.getElementById('rouletteBtn'),
            rouletteResult: document.getElementById('rouletteResult'),
            syncUrl: document.getElementById('syncUrl'),
            syncRoom: document.getElementById('syncRoom'),
            syncKey: document.getElementById('syncKey'),
            toggleSync: document.getElementById('toggleSync'),
            syncPanel: document.getElementById('syncPanel'),
            btnConnect: document.getElementById('btnConnect'),
            btnSyncNow: document.getElementById('btnSyncNow'),
            syncStatus: document.getElementById('syncStatus'),
            lastSyncChip: document.getElementById('lastSyncChip')
        };
        const fmt = new Intl.NumberFormat('ja-JP');
        const coins = n => fmt.format(n) + ' coin';
        const ts2str = ts => {
            const d = new Date(ts);
            const y = d.getFullYear(), m = String(d.getMonth() + 1).padStart(2, '0'),
                day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`
        };
        const id = () => Math.random().toString(36).slice(2) + Date.now().toString(36);

        function toast(msg) {
            const t = document.getElementById('toast');
            const div = document.createElement('div');
            div.className = 'chip';
            div.textContent = msg;
            t.appendChild(div);
            setTimeout(() => div.remove(), 2500);
        }

        function saveLocal(skipPush) {
            localStorage.setItem(LS_KEY, JSON.stringify(state));
            if (!skipPush) schedulePush();
        }

        function loadLocal() {
            try {
                const raw = localStorage.getItem(LS_KEY);
                if (raw) {
                    state = JSON.parse(raw)
                }
            } catch (e) {
            }
            if (typeof state.vTick !== 'number') state.vTick = 0;
        }

        const syncStoreKey = 'trpg_sync_kv';
        let syncSettings = {url: '', room: '', key: ''};

        function loadSyncSettings() {
            try {
                const s = JSON.parse(localStorage.getItem(syncStoreKey) || '{}');
                syncSettings = Object.assign({url: '', room: '', key: ''}, s);
            } catch {
            }
            els.syncUrl.value = syncSettings.url;
            els.syncRoom.value = syncSettings.room;
            els.syncKey.value = syncSettings.key;

            // Setup toggle button
            els.toggleSync.addEventListener('click', () => {
                els.syncPanel.classList.toggle('expanded');
                els.toggleSync.textContent = els.syncPanel.classList.contains('expanded') ? '同期設定を隠す' : '同期設定を表示';
            });
        }

        function saveSyncSettings() {
            syncSettings = {
                url: els.syncUrl.value.trim(),
                room: els.syncRoom.value.trim(),
                key: els.syncKey.value.trim()
            };
            localStorage.setItem(syncStoreKey, JSON.stringify(syncSettings));
        }

        // 操作ベースの同期システム
        class OperationBasedSync {
            constructor(serverUrl, roomId, userId) {
                this.serverUrl = serverUrl.replace(/\/+$/,'');
                this.roomId = roomId;
                this.userId = userId || 'anonymous';
                this.lastOperationId = 0;
                this.pollInterval = null;
                this.pendingOperations = new Set();
                this.onStateChanged = null;
            }

            async sendOperation(operation) {
                const opId = operation.opId || `${Date.now()}-${Math.random().toString(36).slice(2)}`;
                const payload = {
                    userId: this.userId,
                    operation: {
                        ...operation,
                        opId,
                        timestamp: Date.now()
                    }
                };

                try {
                    const res = await fetch(`${this.serverUrl}/operations?room=${this.roomId}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!res.ok) {
                        const txt = await res.text();
                        console.error('sendOperation failed', res.status, txt);
                        return null;
                    }

                    const data = await res.json();
                    // track pending by opId so poll can ignore echo
                    this.pendingOperations.add(opId);
                    return data.operationId || null;
                } catch (err) {
                    console.error('sendOperation error', err);
                    return null;
                }
            }

            async sendBatchOperations(opsArray) {
                const payload = {
                    userId: this.userId,
                    operation: { type: 'BATCH', operations: opsArray.map(o => ({ ...o, opId: o.opId || `${Date.now()}-${Math.random().toString(36).slice(2)}`, timestamp: Date.now() })) }
                };
                try {
                    const res = await fetch(`${this.serverUrl}/operations?room=${this.roomId}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!res.ok) {
                        console.error('sendBatchOperations failed', res.status);
                        return null;
                    }
                    const data = await res.json();
                    return data;
                } catch (err) {
                    console.error('sendBatchOperations error', err);
                    return null;
                }
            }

            async pollOperations() {
                try {
                    const res = await fetch(`${this.serverUrl}/operations?room=${this.roomId}&since=${this.lastOperationId}`);
                    if (res.status === 204) return;
                    if (!res.ok) {
                        console.error('pollOperations failed', res.status);
                        return;
                    }
                    const data = await res.json();
                    if (!data || !data.operations || data.operations.length === 0) return;

                    for (const op of data.operations) {
                        // ignore if we originated it recently
                        if (op.operation && this.pendingOperations.has(op.operation.opId)) {
                            this.pendingOperations.delete(op.operation.opId);
                            continue;
                        }
                        this.applyOperation(op);
                    }

                    this.lastOperationId = data.latestId || this.lastOperationId;
                    if (this.onStateChanged) this.onStateChanged();
                } catch (err) {
                    console.error('pollOperations error', err);
                }
            }

            applyOperation(op) {
                const operation = op.operation || {};
                switch (operation.type) {
                    case 'TRANSFER': {
                        const from = findUserById(operation.fromId);
                        const to = findUserById(operation.toId);
                        if (!from || !to) return;
                        if (from.balance < operation.amount) return;
                        from.balance -= operation.amount;
                        to.balance += operation.amount;
                        addTx({ type: 'transfer', from: from.id, to: to.id, amount: operation.amount, memo: operation.memo || '' });
                        bump();
                        saveLocal(true);
                        break;
                    }

                    case 'CREATE_LISTING': {
                        const l = {
                            id: operation.listingId || `listing_${Date.now()}_${Math.random().toString(36).substr(2,6)}`,
                            title: operation.title,
                            price: operation.price,
                            desc: operation.desc || operation.description || '',
                            sellerId: operation.sellerId || op.userId,
                            active: true,
                            ts: operation.timestamp || Date.now(),
                            qty: operation.qty || 1,
                            sold: 0
                        };
                        state.listings.unshift(l);
                        bump();
                        saveLocal(true);
                        break;
                    }

                    case 'PURCHASE': {
                        const buyer = findUserById(operation.buyerId);
                        const listing = state.listings.find(x => x.id === operation.listingId && x.active);
                        if (!buyer || !listing) return;
                        if (buyer.balance < listing.price) return;
                        const seller = findUserById(listing.sellerId);
                        if (!seller) return;
                        // fee to jackpot (existing logic uses 10%)
                        const fee = Math.floor(listing.price * 0.10);
                        const sellerReceive = listing.price - fee;
                        const j = jackpotUser();
                        buyer.balance -= listing.price;
                        seller.balance += sellerReceive;
                        if (j) j.balance += fee;
                        listing.sold = (listing.sold || 0) + 1;
                        if (listing.sold >= (listing.qty || 1)) listing.active = false;
                        const right = { id: operation.rightId || `right_${Date.now()}_${Math.random().toString(36).substr(2,6)}`, listingId: listing.id, title: listing.title, buyerId: buyer.id, sellerId: seller.id, ts: Date.now(), status: 'owned', executed: false };
                        state.rights.unshift(right);
                        addTx({ type: 'purchase', from: buyer.id, to: seller.id, amount: listing.price, listingId: listing.id, title: listing.title, memo: '権利購入（手数料10%）' });
                        addTx({ type: 'fee', from: seller.id, to: j ? j.id : 'jpot', amount: fee, listingId: listing.id, title: listing.title, memo: '販売手数料' });
                        bump();
                        saveLocal(true);
                        break;
                    }

                    case 'SET_VALUE': {
                        state[operation.key] = operation.value;
                        bump();
                        saveLocal(true);
                        break;
                    }

                    case 'INCREMENT': {
                        state[operation.key] = (state[operation.key] || 0) + operation.amount;
                        bump();
                        saveLocal(true);
                        break;
                    }

                    case 'ADD_ITEM': {
                        if (!state[operation.listKey]) state[operation.listKey] = [];
                        state[operation.listKey].push(operation.item);
                        bump();
                        saveLocal(true);
                        break;
                    }

                    case 'REMOVE_ITEM': {
                        if (!state[operation.listKey]) return;
                        const idx = state[operation.listKey].findIndex(i => i.id === operation.itemId);
                        if (idx !== -1) state[operation.listKey].splice(idx,1);
                        bump();
                        saveLocal(true);
                        break;
                    }

                    default:
                        console.warn('Unknown operation type (client apply):', operation.type);
                }
            }

            startPolling(interval = 1000) {
                if (this.pollInterval) return;
                els.syncStatus.textContent = '同期中';
                this.pollInterval = setInterval(() => this.pollOperations(), interval);
            }

            stopPolling() {
                if (!this.pollInterval) return;
                clearInterval(this.pollInterval);
                this.pollInterval = null;
                els.syncStatus.textContent = '停止中';
            }
        }

        let sync = null;

        async function kvFetchLatest() {
            if (!syncSettings.url || !syncSettings.room || !syncSettings.key) return;
            try {
                const u = new URL(syncSettings.url);
                u.searchParams.set('room', syncSettings.room);
                u.searchParams.set('key', syncSettings.key);
                const lastV = Number(localStorage.getItem('trpg_sync_kv_v') || 0);
                u.searchParams.set('v', String(lastV));
                const res = await fetch(u.toString(), {method: 'GET', headers: {accept: 'application/json'}});
                if (res.status === 204) {                       // 変更なし
                    els.lastSyncChip.textContent = '最終同期：変更なし ' + new Date().toLocaleTimeString();
                    return;
                }
                if (!res.ok) return;                             // 2xx以外は無視
                const data = await res.json();
                if (typeof data.v === 'number') localStorage.setItem('trpg_sync_kv_v', String(data.v));
                // ここに来るのはJSONがある時だけ
                if (data && data.state && data.state.vTick > (state.vTick || 0)) {
                    const keep = state.currentUserId;
                    state = data.state;
                    state.currentUserId = keep || null;
                    saveLocal(true);
                    renderAll();
                    els.lastSyncChip.textContent = '最終同期：受信 ' + new Date().toLocaleTimeString();
                }
            } catch (e) {
            }
        }

        async function kvPushState() {
            if (!syncSettings.url || !syncSettings.room || !syncSettings.key) return;
            try {
                const u = new URL(syncSettings.url);
                u.searchParams.set('room', syncSettings.room);
                u.searchParams.set('key', syncSettings.key);
                const payload = JSON.stringify({
                    vTick: state.vTick,
                    state: Object.assign({}, state, {currentUserId: null})
                });
                const res = await fetch(u.toString(), {
                    method: 'PUT',
                    headers: {'content-type': 'application/json'},
                    body: payload
                });
                if (res.ok) {
                      // 送信側でも lastV を即更新
                  try {
                    const data = await res.json();
                    if (typeof data.v === 'number') {
                      localStorage.setItem('trpg_sync_kv_v', String(data.v));
                    }
                  } catch {}
                    els.lastSyncChip.textContent = '最終同期：送信 ' + new Date().toLocaleTimeString();
                }
            } catch (e) {
            }
        }

        async function sha256(text) {
            const enc = new TextEncoder().encode(text);
            const buf = await crypto.subtle.digest('SHA-256', enc);
            return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function findUserById(uid) {
            return state.users.find(u => u.id === uid) || null;
        }

        function findUserByName(name) {
            return state.users.find(u => u.name === name) || null;
        }

        function jackpotUser() {
            return findUserById(state.jackpotUserId);
        }

        function isJackpot(u) {
            return u && u.id === state.jackpotUserId;
        }

        function nameOf(uid) {
            const u = findUserById(uid);
            return u ? u.name : '';
        }

        function ensureJackpotUser() {
            let j = findUserByName(JACKPOT_NAME);
            if (!j) {
                j = {id: id(), name: JACKPOT_NAME, passHash: '', balance: 0, streakCount: 0, lastMorningDate: ''};
                state.users.unshift(j);
            }
            state.jackpotUserId = j.id;
        }

        function addTx(obj) {
            const base = {id: id(), ts: Date.now()};
            state.txs.unshift(Object.assign(base, obj));
        }

        function bump() {
            state.vTick = (state.vTick || 0) + 1;
        }

        async function register(name, pass) {
            name = (name || '').trim();
            if (!name || !pass) {
                toast('ユーザー名とパスワードを入力');
                return;
            }
            if (name === JACKPOT_NAME) {
                toast('この名前は予約されています');
                return;
            }
            if (state.users.some(u => u.name === name)) {
                toast('そのユーザー名は使用済み');
                return;
            }
            const passHash = await sha256(pass);
            const u = {id: id(), name, passHash, balance: INITIAL_BAL, streakCount: 0, lastMorningDate: ''};
            state.users.push(u);
            state.currentUserId = u.id;
            state.lastRealUserId = u.id;
            addTx({type: 'mint', to: u.id, amount: INITIAL_BAL, memo: '初期発行'});
            bump();
            saveLocal();
            renderAll();
            // If sync is active, update its userId to the newly registered user
            if (sync) {
                try { sync.userId = u.id; } catch (e) {}
            }
            toast('登録完了');
        }

        async function login(name, pass) {
            name = (name || '').trim();
            const u = findUserByName(name);
            if (!u) {
                toast('ユーザーが見つかりません');
                return;
            }
            if (isJackpot(u)) {
                state.currentUserId = u.id;
            } else {
                const passHash = await sha256(pass || '');
                if (u.passHash !== passHash) {
                    toast('パスワードが違います');
                    return;
                }
                state.currentUserId = u.id;
                state.lastRealUserId = u.id;
            }
            localStorage.setItem('last_current_uid', state.currentUserId || '');
            saveLocal(true);
            renderAll();
            // Update sync userId so subsequent operations carry correct user identity
            if (sync) {
                try { sync.userId = state.currentUserId || (state.lastRealUserId || 'anonymous'); } catch (e) {}
            }
            toast('ログイン');
        }

        function logout() {
            state.currentUserId = null;
            localStorage.setItem('last_current_uid', '');
            saveLocal(true);
            renderAll();
            // reflect logout in sync
            if (sync) {
                try { sync.userId = state.lastRealUserId || 'anonymous'; } catch (e) {}
            }
            toast('ログアウト');
        }

        function currentUser() {
            return findUserById(state.currentUserId);
        }

        async function transfer(toId, amount, memo) {
            const from = currentUser();
            if (!from) {
                toast('ログインが必要');
                return;
            }
            amount = Math.floor(Number(amount));
            if (!(amount > 0)) {
                toast('金額は1以上の整数');
                return;
            }
            const to = findUserById(toId);
            if (!to) {
                toast('送信先が不正');
                return;
            }
            if (from.id === toId) {
                toast('自分自身へは送れません');
                return;
            }
            if (isJackpot(to)) {
                toast('ジャックポットへは直接送金できません');
                return;
            }
            if (from.balance < amount) {
                toast('残高不足');
                return;
            }

            const op = {
                type: 'TRANSFER',
                fromId: from.id,
                toId: to.id,
                amount: amount,
                memo: (memo || '').trim(),
                opId: `transfer_${Date.now()}_${Math.random().toString(36).substr(2,6)}`
            };

            if (sync) {
                const res = await sync.sendOperation(op);
                if (!res) toast('同期送信に失敗しました');
            } else {
                from.balance -= amount;
                to.balance += amount;
                addTx({type: 'transfer', from: from.id, to: to.id, amount, memo: (memo || '').trim()});
                bump();
                saveLocal();
                renderAll();
            }
        }

    async function createListing(title, price, desc) {
            const seller = currentUser();
            if (!seller) {
                toast('ログインが必要');
                return;
            }
            if (isJackpot(seller)) {
                toast('JPOTでは出品不可');
                return;
            }
            title = (title || '').trim();
            desc = (desc || '').trim();
            price = Math.floor(Number(price));
          let qty = Math.floor(Number((els.listQty && els.listQty.value) || 1));
            if (!title || !(price > 0) || !(qty > 0)) {
                toast('入力を確認');
                return;
            }
            const op = {
                type: 'CREATE_LISTING',
                title,
                price,
                desc,
                sellerId: seller.id,
                qty,
                listingId: `listing_${Date.now()}_${Math.random().toString(36).substr(2,6)}`,
                opId: `create_${Date.now()}_${Math.random().toString(36).substr(2,6)}`
            };

            if (sync) {
                const res = await sync.sendOperation(op);
                if (!res) toast('同期送信に失敗しました');
            } else {
                const l = {id: id(), title, price, desc, sellerId: seller.id, active: true, ts: Date.now(), qty, sold: 0};
                state.listings.unshift(l);
                bump();
                saveLocal();
                renderAll();
            }
        }

    async function buyListing(listingId) {
            const buyer = currentUser();
            if (!buyer) {
                toast('ログインが必要');
                return;
            }
            const l = state.listings.find(x => x.id === listingId && x.active);
            if (!l) {
                toast('出品が見つかりません');
                return;
            }
            if (l.sellerId === buyer.id) {
                toast('自分の出品は購入不可');
                return;
            }
            if (isJackpot(buyer)) {
                toast('JPOTでは購入不可');
                return;
            }
            const remaining = (l.qty || 1) - (l.sold || 0);
            if (remaining <= 0) {
                toast('在庫切れ');
                l.active = false;
                bump();
                saveLocal();
                renderAll();
                return;
            }
            if (buyer.balance < l.price) {
                toast('残高不足');
                return;
            }
            const op = {
                type: 'PURCHASE',
                buyerId: buyer.id,
                listingId: l.id,
                opId: `purchase_${Date.now()}_${Math.random().toString(36).substr(2,6)}`
            };

            if (sync) {
                const res = await sync.sendOperation(op);
                if (!res) toast('同期送信に失敗しました');
            } else {
                const seller = findUserById(l.sellerId);
                const j = jackpotUser();
                const fee = Math.floor(l.price * 0.10);
                const sellerReceive = l.price - fee;
                buyer.balance -= l.price;
                seller.balance += sellerReceive;
                if (j) j.balance += fee;
                const right = {
                    id: id(),
                    listingId: l.id,
                    title: l.title,
                    buyerId: buyer.id,
                    sellerId: seller.id,
                    ts: Date.now(),
                    status: 'owned',
                    executed: false
                };
                state.rights.unshift(right);
                l.sold = (l.sold || 0) + 1;
                if (l.sold >= l.qty) {
                    l.active = false;
                }
                addTx({ type: 'purchase', from: buyer.id, to: seller.id, amount: l.price, listingId: l.id, title: l.title, memo: '権利購入（手数料10%）' });
                addTx({ type: 'fee', from: seller.id, to: j ? j.id : 'jpot', amount: fee, listingId: l.id, title: l.title, memo: '販売手数料' });
                bump();
                saveLocal();
                renderAll();
            }
        }

        function deleteListing(listingId) {
            const me = currentUser();
            if (!me) {
                toast('ログインが必要');
                return;
            }
            const idx = state.listings.findIndex(x => x.id === listingId);
            if (idx < 0) {
                toast('出品が見つかりません');
                return;
            }
            const l = state.listings[idx];
            if (l.sellerId !== me.id) {
                toast('自分の出品のみ削除可');
                return;
            }
            if ((l.sold || 0) > 0) {
                toast('購入履歴があるため削除不可');
                return;
            }
            const op = { type: 'REMOVE_LISTING', listingId: listingId, opId: `rm_${Date.now()}_${Math.random().toString(36).substr(2,6)}` };
            if (sync) {
                sync.sendOperation(op);
            } else {
                state.listings.splice(idx, 1);
                bump();
                saveLocal();
                renderAll();
            }
        }

        function toggleListingActive(listingId) {
            const me = currentUser();
            if (!me) {
                toast('ログインが必要');
                return;
            }
            const l = state.listings.find(x => x.id === listingId);
            if (!l) {
                toast('出品が見つかりません');
                return;
            }
            if (l.sellerId !== me.id) {
                toast('自分の出品のみ');
                return;
            }
            const op = { type: 'TOGGLE_LISTING', listingId, opId: `tgl_${Date.now()}_${Math.random().toString(36).substr(2,6)}` };
            if (sync) {
                sync.sendOperation(op);
            } else {
                l.active = !l.active;
                bump();
                saveLocal();
                renderAll();
            }
        }

        function buyerReturn(rightId) {
            const me = currentUser();
            if (!me) {
                toast('ログインが必要');
                return;
            }
            const r = state.rights.find(x => x.id === rightId);
            if (!r) return;
            if (r.buyerId !== me.id || r.status !== 'owned') {
                toast('保有中のみ返品可');
                return;
            }
            const l = state.listings.find(x => x.id === r.listingId);
            const seller = findUserById(r.sellerId);
            const refund = Math.floor(l.price * 0.90);
            if (seller.balance < refund) {
                toast('販売者の残高不足');
                return;
            }
            seller.balance -= refund;
            const buyer = findUserById(r.buyerId);
            buyer.balance += refund;
            l.sold = Math.max(0, (l.sold || 0) - 1);
            if (l.sold < l.qty) {
                l.active = true;
            }
            state.rights = state.rights.filter(x => x.id !== rightId);
            addTx({
                type: 'return',
                from: seller.id,
                to: buyer.id,
                listingId: l.id,
                title: r.title,
                amount: refund,
                memo: '購入者が返品（手数料は返らない）'
            });
            bump();
            saveLocal();
            renderAll();
        }

        function buyerRequest(rightId) {
            const me = currentUser();
            if (!me) {
                toast('ログインが必要');
                return;
            }
            const r = state.rights.find(x => x.id === rightId);
            if (!r) return;
            if (r.buyerId !== me.id || r.status !== 'owned') {
                toast('申請できません');
                return;
            }
            r.status = 'request';
            addTx({
                type: 'execute-request',
                from: r.buyerId,
                to: r.sellerId,
                listingId: r.listingId,
                title: r.title,
                memo: '実行申請'
            });
            bump();
            saveLocal();
            renderAll();
        }

        function sellerRespond(rightId, action) {
            const me = currentUser();
            if (!me) {
                toast('ログインが必要');
                return;
            }
            const r = state.rights.find(x => x.id === rightId);
            if (!r) return;
            if (r.sellerId !== me.id || r.status !== 'request') {
                toast('対象外');
                return;
            }
            const l = state.listings.find(x => x.id === r.listingId);
            if (action === 'exec') {
                r.status = 'seller_executed';
                addTx({
                    type: 'execute-done',
                    from: r.sellerId,
                    to: r.buyerId,
                    listingId: r.listingId,
                    title: r.title,
                    memo: '販売者が実行'
                });
            } else {
                const seller = findUserById(r.sellerId);
                if (seller.balance < l.price) {
                    toast('残額不足');
                    return;
                }
                r.status = 'seller_cancel_requested';
                addTx({
                    type: 'execute-cancel-ask',
                    from: r.sellerId,
                    to: r.buyerId,
                    listingId: r.listingId,
                    title: r.title,
                    memo: '販売者がキャンセル申請'
                });
            }
            bump();
            saveLocal();
            renderAll();
        }

        function buyerFinalize(rightId) {
            const me = currentUser();
            if (!me) {
                toast('ログインが必要');
                return;
            }
            const r = state.rights.find(x => x.id === rightId);
            if (!r) return;
            if (r.buyerId !== me.id) {
                toast('あなたは購入者ではありません');
                return;
            }
            const l = state.listings.find(x => x.id === r.listingId);
            if (r.status === 'seller_executed') {
                r.status = 'finalized';
                r.executed = true;
                addTx({
                    type: 'execute-finalize',
                    from: r.buyerId,
                    to: r.sellerId,
                    listingId: r.listingId,
                    title: r.title,
                    memo: '購入者が実行確認（確定）'
                });
            } else if (r.status === 'seller_cancel_requested') {
                const seller = findUserById(r.sellerId);
                const buyer = findUserById(r.buyerId);
                if (seller.balance < l.price) {
                    toast('販売者の残高不足');
                    return;
                }
                seller.balance -= l.price;
                buyer.balance += l.price;
                l.sold = Math.max(0, (l.sold || 0) - 1);
                if (l.sold < l.qty) {
                    l.active = true;
                }
                state.rights = state.rights.filter(x => x.id !== rightId);
                addTx({
                    type: 'execute-cancel-ok',
                    from: r.buyerId,
                    to: r.sellerId,
                    listingId: r.listingId,
                    title: r.title,
                    amount: l.price,
                    memo: 'キャンセル返金（全額）確定'
                });
            } else {
                toast('確定不可の状態');
                return;
            }
            bump();
            saveLocal();
            renderAll();
        }

        const MORNING_HOUR = 7, MORNING_MINUTE = 30, MORNING_BASE = 1000, STREAK_MAX = 30, STREAK_INC = 100;

        function todayKey() {
            const d = new Date();
            const y = d.getFullYear(), m = String(d.getMonth() + 1).padStart(2, '0'),
                day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`;
        }

        function beforeDeadline() {
            const n = new Date();
            if (n.getHours() < MORNING_HOUR) return true;
            if (n.getHours() > MORNING_HOUR) return false;
            return n.getMinutes() <= MORNING_MINUTE;
        }

        function canClaimMorning() {
            const me = currentUser();
            if (!me) return {ok: false, reason: 'ログインしてください'};
            if (isJackpot(me)) return {ok: false, reason: 'ジャックポットは朝活対象外'};
            const t = todayKey();
            if (me.lastMorningDate === t) return {ok: false, reason: '本日は受取済み'};
            if (!beforeDeadline()) return {ok: false, reason: '7:30を過ぎています'};
            return {ok: true};
        }

        function updateMorningButton() {
            const me = currentUser();
            const s = canClaimMorning();
            els.morningBtn.disabled = !s.ok;
            const cnt = me ? (me.streakCount || 0) : 0;
            els.streakBadge.textContent = '🔥' + cnt;
        }

        function morningClaim() {
            const me = currentUser();
            const c = canClaimMorning();
            if (!c.ok) {
                toast(c.reason);
                updateMorningButton();
                return;
            }
            const today = todayKey();
            if (me.lastMorningDate) {
                const diff = Math.round((new Date(today) - new Date(me.lastMorningDate)) / 86400000);
                me.streakCount = (diff === 1) ? Math.min((me.streakCount || 0) + 1, STREAK_MAX) : 1;
            } else {
                me.streakCount = 1;
            }
            me.lastMorningDate = today;
            const bonus = MORNING_BASE + STREAK_INC * (me.streakCount || 0);
            me.balance += bonus;
            addTx({type: 'mint', to: me.id, amount: bonus, memo: `朝活（連続${me.streakCount}日）`});
            bump();
            saveLocal();
            renderAll();
        }

        function renderJackpot() {
            const j = jackpotUser();
            const bal = j ? j.balance : 0;
            document.getElementById('jackpotChip').textContent = '現在: ' + fmt.format(bal) + ' coin';
            els.jackpotBadge.textContent = 'JPOT: ' + fmt.format(bal);
            const me = currentUser();
            els.rouletteBtn.disabled = !me || (me && me.balance < 100) || bal <= 0 || (me && isJackpot(me));
        }

        function rouletteSpin() {
            const me = currentUser();
            if (!me) {
                toast('ログインが必要');
                return;
            }
            if (isJackpot(me)) {
                toast('ジャックポットでは遊べません');
                return;
            }
            if (me.balance < 100) {
                toast('残高不足');
                return;
            }
            const j = jackpotUser();
            if (!j) {
                toast('JPOTユーザーが見つかりません');
                return;
            }
            if (j.balance <= 0) {
                toast('ジャックポットが空です');
                return;
            }
            me.balance -= 100;
            j.balance += 100;
            addTx({type: 'jpot-fee', from: me.id, to: j.id, amount: 100, memo: 'ルーレット参加費'});
            const roll = Math.random();
            if (roll < 0.01) {
                const payout = j.balance;
                if (payout > 0) {
                    me.balance += payout;
                    addTx({type: 'jackpot', from: j.id, to: me.id, amount: payout, memo: '🎉 ジャックポット当選'});
                    j.balance = 0;
                    document.getElementById('rouletteResult').textContent = '結果: JACKPOT!! +' + fmt.format(payout) + ' coin';
                } else {
                    document.getElementById('rouletteResult').textContent = '結果: JACKPOT 0';
                }
                bump();
                saveLocal();
                renderAll();
                return;
            }
            const prizes = [{p: 0.40, v: 0}, {p: 0.25, v: 50}, {p: 0.18, v: 100}, {p: 0.09, v: 150}, {
                p: 0.05,
                v: 200
            }, {p: 0.02, v: 400}, {p: 0.0099, v: 700}];
            let r = Math.random(), acc = 0, val = 0;
            for (const it of prizes) {
                acc += it.p;
                if (r < acc) {
                    val = it.v;
                    break;
                }
            }
            const payout = Math.min(j.balance, val);
            if (payout > 0) {
                me.balance += payout;
                j.balance -= payout;
                addTx({type: 'roulette', from: j.id, to: me.id, amount: payout, memo: 'ルーレット払い出し'});
            }
            document.getElementById('rouletteResult').textContent = '結果: +' + fmt.format(payout) + ' coin';
            bump();
            saveLocal();
            renderAll();
        }

        function renderSummary() {
            els.kpiMembers.textContent = state.users.filter(u => !isJackpot(u)).length;
            els.kpiSupply.textContent = coins(state.users.reduce((s, u) => s + (u.balance || 0), 0));
            const last = state.txs[0];
            els.lastActivity.textContent = last ? '最終更新：' + ts2str(last.ts) : '最終更新：—';
        }

        function renderWallets() {
            const list = els.walletList;
            list.innerHTML = '';
            state.users.forEach(u => {
                const row = document.createElement('div');
                row.style.cssText = 'padding:8px 10px;border:1px solid #60efff22;border-radius:10px;display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;background:#0e1836';
                row.innerHTML = '<div style="font-weight:750">' + u.name + (u.id === state.currentUserId ? '（自分）' : '') + '</div><div class="pill">' + coins(u.balance) + '</div>';
                list.appendChild(row);
            });
        }

        function renderHeaderUser() {
            const me = currentUser();
            els.userBadge.textContent = me ? (me.name + ' / ' + coins(me.balance)) : '未ログイン';
            els.fromFixed.value = me ? (me.name + '（残高：' + fmt.format(me.balance) + '）') : '未ログイン';
            updateMorningButton();
            renderJackpot();
        }

        function renderSelects() {
            const me = currentUser();
            let list = state.users.filter(u => !me || u.id !== me.id);
            if (me && !isJackpot(me)) list = list.filter(u => !isJackpot(u));
            els.toSelect.innerHTML = '<option value="">選択</option>' + list.map(u => '<option value="' + u.id + '">' + u.name + '（' + fmt.format(u.balance) + '）</option>').join('');
            els.memberFilter.innerHTML = '<option value="">すべて</option>' + state.users.map(u => '<option value="' + u.id + '">' + u.name + '</option>').join('');
        }

        function renderHistory() {
            const q = (els.searchInput.value || '').toLowerCase();
            const f = els.memberFilter.value || '';
            els.historyBody.innerHTML = '';
            const frag = document.createDocumentFragment();
            state.txs.filter(t => {
                if (f && !((t.from && t.from === f) || (t.to && t.to === f) || (t.actedBy && t.actedBy === f))) return false;
                if (!q) return true;
                const text = ((t.memo || '') + ' ' + (t.title || '')).toLowerCase();
                return text.includes(q);
            }).forEach(t => {
                const tr = document.createElement('tr');
                const c = x => {
                    const td = document.createElement('td');
                    td.innerHTML = x;
                    return td;
                };
                tr.append(c(ts2str(t.ts)), c(typeLabel(t.type)), c('<span class="pill">' + (nameOf(t.from) || '—') + '</span>'), c('<span class="pill">' + (nameOf(t.to) || '—') + '</span>'), c(t.title ? (t.title + (t.memo ? (' / ' + t.memo) : '')) : (t.memo || '')), c('<span>' + (t.amount ? fmt.format(t.amount) : '') + '</span>'));
                frag.appendChild(tr);
            });
            els.historyBody.appendChild(frag);
        }

        function typeLabel(tp) {
            return tp === 'transfer' ? '送金' : tp === 'purchase' ? '購入' : tp === 'execute-request' ? '実行申請' : tp === 'execute-done' ? '実行（販売者）' : tp === 'execute-finalize' ? '実行確定（購入者）' : tp === 'execute-cancel-ask' ? 'キャンセル申請（販売者）' : tp === 'execute-cancel-ok' ? 'キャンセル確定（購入者）' : tp === 'return' ? '返品' : tp === 'mint' ? '発行' : tp === 'fee' ? '手数料' : tp === 'roulette' ? 'ルーレット' : tp === 'jackpot' ? 'ジャックポット' : tp === 'jpot-fee' ? 'JPOT入金' : '—';
        }

        function renderListings() {
            els.listingBody.innerHTML = '';
            const me = currentUser();
            state.listings.forEach(l => {
                const remaining = (l.qty || 1) - (l.sold || 0);
                const tr = document.createElement('tr');

                function td(text) {
                    const x = document.createElement('td');
                    x.textContent = text;
                    return x;
                }

                tr.append(td(l.title + (l.active ? '' : '（停止中）')), (function () {
                    const x = document.createElement('td');
                    x.innerHTML = '<b>' + fmt.format(l.price) + '</b>';
                    return x;
                })(), td(remaining + '/' + l.qty), td(nameOf(l.sellerId)), td(l.desc || ''));
                const tdA = document.createElement('td');
                if (me) {
                    if (l.sellerId === me.id) {
                        const tog = document.createElement('button');
                        tog.className = 'btn secondary';
                        tog.textContent = l.active ? '停止' : '公開';
                        tog.onclick = () => toggleListingActive(l.id);
                        const del = document.createElement('button');
                        del.className = 'btn secondary';
                        del.textContent = '削除';
                        del.disabled = (l.sold || 0) > 0;
                        del.onclick = () => deleteListing(l.id);
                        tdA.append(tog, document.createTextNode(' '), del);
                    } else {
                        const buy = document.createElement('button');
                        buy.className = 'btn';
                        buy.textContent = '購入';
                        buy.disabled = !l.active || remaining <= 0 || (me && isJackpot(me));
                        buy.onclick = () => {
                            buy.disabled = true;
                            buyListing(l.id);
                        };
                        tdA.appendChild(buy);
                    }
                } else {
                    const s = document.createElement('span');
                    s.className = 'chip';
                    s.textContent = 'ログインしてください';
                    tdA.appendChild(s);
                }
                tr.appendChild(tdA);
                els.listingBody.appendChild(tr);
            });
        }

        function renderRights() {
            els.rightsBody.innerHTML = '';
            const me = currentUser();
            if (!me) return;
            state.rights.filter(r => r.buyerId === me.id).forEach(r => {
                const tr = document.createElement('tr');

                function td(t) {
                    const x = document.createElement('td');
                    x.textContent = t;
                    return x;
                }

                tr.append(td(ts2str(r.ts)), td(r.title), td(nameOf(r.sellerId)), td(statusLabel(r)));
                const tdA = document.createElement('td');
                tdA.appendChild(rightActionButtons(r));
                tr.appendChild(tdA);
                els.rightsBody.appendChild(tr);
            });
        }

        function statusLabel(r) {
            return r.status === 'owned' ? '保有中' : r.status === 'request' ? '販売者の対応待ち' : r.status === 'seller_executed' ? '販売者が実行済（確認待ち）' : r.status === 'seller_cancel_requested' ? '販売者がキャンセル申請（確認待ち）' : r.status === 'finalized' ? (r.executed ? '確定（実行済）' : '確定（キャンセル）') : '—';
        }

        function rightActionButtons(r) {
            const span = document.createElement('span');
            if (r.status === 'owned') {
                const btn = document.createElement('button');
                btn.className = 'btn';
                btn.textContent = '実行を申請';
                btn.onclick = () => {
                    btn.disabled = true;
                    buyerRequest(r.id);
                };
                const ret = document.createElement('button');
                ret.className = 'btn secondary';
                ret.textContent = '返品';
                ret.onclick = () => {
                    ret.disabled = true;
                    buyerReturn(r.id);
                };
                span.append(btn, document.createTextNode(' '), ret);
            } else if (r.status === 'seller_executed') {
                const btn = document.createElement('button');
                btn.className = 'btn';
                btn.textContent = '済（確定）';
                btn.onclick = () => {
                    btn.disabled = true;
                    buyerFinalize(r.id);
                };
                span.appendChild(btn);
            } else if (r.status === 'seller_cancel_requested') {
                const btn = document.createElement('button');
                btn.className = 'btn secondary';
                btn.textContent = 'キャンセル承認（確定）';
                btn.onclick = () => {
                    btn.disabled = true;
                    buyerFinalize(r.id);
                };
                span.appendChild(btn);
            } else {
                const chip = document.createElement('span');
                chip.className = 'chip';
                chip.textContent = '操作なし';
                span.appendChild(chip);
            }
            return span;
        }

        function switchMarketSub(which) {
            document.querySelectorAll('#tab-market .tab').forEach(s => s.classList.toggle('active', s.dataset.sub === which));
            els.marketSell.style.display = which === 'sell' ? 'block' : 'none';
            els.marketList.style.display = which === 'list' ? 'block' : 'none';
        }

        function renderTabs() {
            const show = name => {
                els.tabTransfer.style.display = name === 'transfer' ? 'block' : 'none';
                els.tabMarket.style.display = name === 'market' ? 'block' : 'none';
                els.tabMyRights.style.display = name === 'myrights' ? 'block' : 'none';
                els.tabGamble.style.display = name === 'gamble' ? 'block' : 'none';
            };
            const active = document.querySelector('.card .hd .tabbar .tab.active');
            show(active ? active.dataset.tab : 'transfer');
        }

        function renderAll() {
            renderSummary();
            renderWallets();
            renderHeaderUser();
            renderSelects();
            renderHistory();
            renderListings();
            renderRights();
            renderTabs();
        }

        els.registerBtn.addEventListener('click', () => register(els.regName.value, els.regPass.value));
        els.loginBtn.addEventListener('click', () => login(els.loginName.value, els.loginPass.value));
        els.logoutBtn.addEventListener('click', logout);
        els.sendBtn.addEventListener('click', () => {
            transfer(els.toSelect.value, els.amountInput.value, els.memoInput.value);
            els.amountInput.value = '';
            els.memoInput.value = '';
        });
        els.searchInput.addEventListener('input', renderHistory);
        els.memberFilter.addEventListener('change', renderHistory);
        els.exportBtn.addEventListener('click', () => {
            const blob = new Blob([JSON.stringify(state, null, 2)], {type: 'application/json'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'trpg_token_v14.json';
            a.click();
            URL.revokeObjectURL(a.href);
        });
        els.importFile.addEventListener('change', e => {
            const f = e.target.files[0];
            if (!f) return;
            const r = new FileReader();
            r.onload = ev => {
                try {
                    const data = JSON.parse(ev.target.result);
                    const keep = state.currentUserId;
                    state = Object.assign({
                        version: 14,
                        approval: {active: false, votes: {}},
                        lastRealUserId: null,
                        vTick: (state.vTick || 0) + 1
                    }, data);
                    state.currentUserId = keep || null;
                    ensureJackpotUser();
                    saveLocal();
                    renderAll();
                } catch {
                    toast('読み込み失敗')
                }
            };
            r.readAsText(f);
            e.target.value = '';
        });
        document.querySelectorAll('.card .hd .tabbar .tab').forEach(t => t.addEventListener('click', () => {
            document.querySelectorAll('.card .hd .tabbar .tab').forEach(x => x.classList.remove('active'));
            t.classList.add('active');
            renderTabs();
        }));
        els.subtabs.forEach(s => s.addEventListener('click', () => switchMarketSub(s.dataset.sub)));
        els.createListingBtn.addEventListener('click', () => {
          createListing(els.listTitle.value, els.listPrice.value, els.listDesc.value);
        });

        els.morningBtn.addEventListener('click', morningClaim);
        els.rouletteBtn.addEventListener('click', rouletteSpin);
        els.btnConnect.addEventListener('click', () => {
            saveSyncSettings();
            // toggle OperationBasedSync
            if (sync && sync.pollInterval) {
                sync.stopPolling();
                sync = null;
            } else {
                if (syncSettings.url && syncSettings.room) {
                    // ensure current user id used
                    const uid = currentUser() ? currentUser().id : (state.lastRealUserId || 'anonymous');
                    sync = new OperationBasedSync(syncSettings.url, syncSettings.room, uid);
                    sync.onStateChanged = () => {
                        // re-render after ops applied
                        renderAll();
                    };
                    sync.startPolling();
                } else {
                    toast('同期設定を入力してください');
                }
            }
        });
        els.btnSyncNow.addEventListener('click', () => kvFetchLatest());
        loadLocal();
        ensureJackpotUser();
        state.listings.forEach(l => {
            if (typeof l.qty !== 'number') l.qty = 1;
            if (typeof l.sold !== 'number') l.sold = 0;
        });
        state.rights.forEach(r => {
            if (!r.status) {
                r.status = r.executed ? 'finalized' : 'owned';
            }
        });
        loadSyncSettings();
        renderAll();
        if (state.users.filter(u => !isJackpot(u)).length === 0) {
            toast('まずは新規登録してください（初期 10,000 coin） / ジャックポットは誰でもログイン可');
        }

        function jackpotUserInitFix() {
            if (typeof state.jackpot === 'number') {
                jackpotUser().balance += state.jackpot;
                delete state.jackpot;
            }
        }

        jackpotUserInitFix();
    })();
</script>
</body>
</html>
