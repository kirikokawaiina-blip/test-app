<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>trpg鯖 トークン | Cloudflare同期版 v14 (KV-poll)</title>
    <meta name="description" content="Cloudflare Workers + KV を使ったルーム同期（無料プラン対応）。"/>
    <style>body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans JP', sans-serif;
        background: #0b1220;
        color: #e5edf6
    }

    header {
        position: sticky;
        top: 0;
        background: #0b132a99;
        border-bottom: 1px solid #60efff22;
        backdrop-filter: blur(12px)
    }

    .nav {
        max-width: 1200px;
        margin: 0 auto;
        padding: 10px 14px;
        display: grid;
        grid-template-columns:1fr auto;
        gap: 10px;
        align-items: center
    }

    .chip {
        padding: 6px 10px;
        border: 1px solid #60efff33;
        border-radius: 999px;
        color: #94a3b8;
        font-size: 12px
    }

    .btn {
        appearance: none;
        border: 0;
        border-radius: 10px;
        background: linear-gradient(90deg, #15c7b6, #60efff);
        padding: 10px 12px;
        font-weight: 800;
        cursor: pointer
    }

    .btn.secondary {
        background: transparent;
        border: 1px solid #60efff55;
        color: #e5edf6
    }

    .grid {
        max-width: 1260px;
        margin: 16px auto 40px;
        padding: 0 14px;
        display: grid;
        /* make right panel a bit wider and left slightly narrower for balance */
        grid-template-columns:300px 1fr 380px;
        gap: 14px
    }

    @media (max-width: 1100px) {
        .grid {
            grid-template-columns:1fr
        }
    }

    .card {
        background: #0f172acc;
        border: 1px solid #1f2a44;
        border-radius: 16px;
        box-shadow: 0 10px 35px #0007
    }

    .card .hd {
        padding: 10px;
        border-bottom: 1px solid #60efff22
    }

    .card .bd {
        padding: 12px
    }

    .tabbar {
        display: flex;
        gap: 6px;
        flex-wrap: wrap
    }

    .tab {
        padding: 6px 10px;
        border: 1px solid #60efff33;
        border-radius: 999px;
        cursor: pointer
    }

    .tab.active {
        background: #15c7b61a;
        border-color: #60efff66
    }

    .panel {
        border: 1px solid #60efff22;
        border-radius: 10px;
        padding: 10px;
        background: #0c1628bb
    }

    .table {
        width: 100%;
        display: block;
        border: 1px solid #60efff13;
        border-radius: 10px
    }

    .table table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        min-width: 760px
    }

    .table th, .table td {
        padding: 8px 10px;
        border-bottom: 1px solid #60efff10;
        white-space: nowrap
    }

    .pill {
        padding: 4px 8px;
        border: 1px solid #15c7b652;
        border-radius: 999px;
        background: #15c7b61a
    }

    .toast {
        position: fixed;
        right: 12px;
        bottom: 12px;
        display: grid;
        gap: 6px
    }</style>

  <style>
    :root{
      --bg:#0a1024; --bg2:#0d1430; --panel:#0e1836; --line:#60efff22;
      --text:#e6f3ff; --muted:#9fb3c8; --accent:#60efff; --accent2:#2f80ed;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font:14px/1.6 system-ui,Segoe UI,Roboto,Helvetica,Arial;
      color:var(--text); background:linear-gradient(180deg,#060c1a, var(--bg));
    }
    h1,h2,h3{margin:0 0 8px}
    a{color:var(--accent); text-decoration:none}
    .container{max-width:1200px; margin:20px auto; padding:0 16px}

    .card{
      background:var(--panel); 
      border:1px solid var(--line);
      border-radius:16px; 
      padding:16px; 
      box-shadow:0 10px 30px #0004;
    }
    .card .hd{
      display:flex; 
      align-items:center; 
      justify-content:space-between; 
      margin-bottom:12px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--line);
    }
    .card .hd h2, .card .hd h3{
      font-size:15px; 
      font-weight:600;
      margin: 0;
    }
    .card .bd {
            font-size: 13px;
      line-height: 1.5;
    }

        /* compact mode for right log panel */
        .card.compact .bd { font-size: 12px; line-height: 1.3; }
        .card.compact .bd .table table td, .card.compact .bd .table table th { padding: 6px 8px; }
        .card.compact .bd .table { max-height: 800px !important; }
    .tabbar{display:flex; gap:6px}
        .tabbar .tab{
            font-weight:700; padding:6px 10px; border-radius:999px; cursor:pointer;
            border:1px solid var(--line); background:transparent; color:#ffffff; /* inactive = white text */
        }
        .tabbar .tab.active{background:linear-gradient(180deg,var(--accent) ,var(--accent2)); color:#000000 /* active = black text */}

    .btn{
      display:inline-block; 
      padding: 8px 12px; 
      border-radius: 8px; 
      font-weight: 600; 
      font-size: 13px;
      line-height: 1.4;
      border:0; 
      cursor:pointer;
      background:linear-gradient(180deg,var(--accent),var(--accent2)); 
      color:#00121a;
      box-shadow:0 4px 12px #0bf5ff33; 
      transition: all .2s ease;
    }
    .btn:hover {
      transform: translateY(-1px);
      box-shadow:0 6px 16px #0bf5ff44;
    }
    .btn:active{transform:translateY(1px)}
    .btn.secondary{
      background:#1a2a55; color:var(--text); border:1px solid var(--line); box-shadow:none;
    }
    .btn:disabled,.btn.secondary:disabled{opacity:.5; cursor:not-allowed}

    input,select,textarea{
      width:100%; background:#0b1430; color:var(--text); border:1px solid var(--line);
      border-radius:10px; padding:9px 10px; outline:none;
    }
    input::placeholder,textarea::placeholder{color:#7f93ab}

    .grid{
      display:grid; 
      gap:16px;
      max-width: 1440px;
      margin: 0 auto;
    }
    .grid.cols-3{
      grid-template-columns: minmax(280px, 1.2fr) minmax(320px, 2fr) minmax(280px, 1.2fr);
    }
    @media (max-width:1200px) {
      .grid.cols-3{
        grid-template-columns: minmax(280px, 1fr) minmax(320px, 2fr);
      }
    }
    @media (max-width:900px){ 
      .grid.cols-3{
        grid-template-columns:1fr
      } 
    }

    .pill{
      display:inline-block; padding:4px 8px; border-radius:999px; font-weight:750;
      background:#091430; border:1px solid var(--line); color:var(--accent);
    }
    .chip{
      display:inline-block; padding:6px 10px; border-radius:999px; background:#0c1736;
      border:1px solid var(--line); color:var(--muted); font-weight:700;
    }

    table{width:100%; border-collapse:separate; border-spacing:0 8px}
    td,th{padding:8px 10px; text-align:left}
    thead th{color:var(--muted); font-weight:800}
    tbody tr{
      background:#0b1632; 
      border:1px solid var(--line);
      transition: all 0.2s ease;
    }
    tbody tr td:first-child{
      border-top-left-radius:12px; 
      border-bottom-left-radius:12px
    }
    tbody tr td:last-child{
      border-top-right-radius:12px; 
      border-bottom-right-radius:12px
    }
    
    /* Responsive tables */
    .table {
      overflow-x: auto;
      max-width: 100%;
      margin: 0 -16px;
      padding: 0 16px;
      scrollbar-width: thin;
      scrollbar-color: rgba(96,239,255,.2) transparent;
    }
    .table::-webkit-scrollbar {
      height: 6px;
    }
    .table::-webkit-scrollbar-track {
      background: transparent;
    }
    .table::-webkit-scrollbar-thumb {
      background-color: rgba(96,239,255,.2);
      border-radius: 3px;
    }
    
    @media (max-width: 768px) {
      table {
        font-size: 12px;
      }
      td, th {
        padding: 6px 8px;
      }
    }

    #toast{position:fixed; right:16px; bottom:16px; display:flex; flex-direction:column; gap:8px; z-index:9}
    .status{color:var(--muted); font-weight:700}
  </style>

<!-- UI refinements: top panel control, collapsible sync settings, subtle horizontal scrollbars -->
<style id="theme-refinement">
  /* Top panel background (visual only; does not alter layout flow) */
  body::before {
    content: "";
    position: fixed; inset: 0 0 auto 0; height: 56px;
    background: linear-gradient(180deg, rgba(9,14,30,.85), rgba(12,18,38,.5));
    border-bottom: 1px solid rgba(96,239,255,.12);
    pointer-events: none; z-index: 60;
  }

  /* Pin the Start/Stop button globally accessible */
  #btnConnect {
    position: fixed !important;
    top: 10px; right: 14px;
    z-index: 70;
    box-shadow: 0 10px 24px rgba(21,199,182,.35), inset 0 0 0 1px rgba(255,255,255,.18) !important;
  }

  /* Sync panel toggle styles */
  .panel:has(#syncUrl) {
    max-height: 0;
    padding: 0;
    border-width: 0;
    overflow: hidden;
    transition: max-height 0.25s ease, padding 0.25s ease, border-width 0.25s ease;
  }
  .panel:has(#syncUrl).expanded {
    max-height: 680px;
    padding: 10px;
    border-width: 1px;
  }
  #toggleSync {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 12px;
    border-radius: 8px;
    background: rgba(14,24,44,.5);
    border: 1px solid rgba(96,239,255,.22);
    color: var(--text);
    cursor: pointer;
    font-size: 13px;
    font-weight: 600;
    margin-bottom: 8px;
    transition: background-color 0.2s;
  }
  #toggleSync:hover {
    background: rgba(14,24,44,.8);
  }
  #toggleSync::before {
    content: "⚙️";
    font-size: 14px;
  }

  /* Hide the native horizontal scrollbars but keep scrolling */
  /* WebKit */
  *::-webkit-scrollbar:horizontal { height: 0 !important; }
  /* Firefox (only for common horizontal containers) */
  .table, .scroll-x, [data-scroll="x"] { scrollbar-width: none; }
  .table, .scroll-x, [data-scroll="x"] { -ms-overflow-style: none; }
  .table::-webkit-scrollbar, .scroll-x::-webkit-scrollbar, [data-scroll="x"]::-webkit-scrollbar { display: none; }

  /* Optional visual cue: subtle edge gradients on horizontal-overflow containers */
  .table, .scroll-x, [data-scroll="x"] {
    position: relative;
    background: rgba(13,22,40,.4);
    mask-image: linear-gradient(to right, transparent 0, black 10px, black calc(100% - 10px), transparent 100%);
  }

  /* Ensure main content doesn't sit under the fixed top panel */
  main, .container { padding-top: 56px !important; }
  
    /* Card-level vertical scrolling for long lists (market, rights, history, etc.)
       Make tables inside cards scroll vertically when content grows, but visually hide scrollbars. */
    .card .bd .table {
        max-height: 420px;
        overflow-y: auto;
        /* keep horizontal scrolling when needed */
        overflow-x: auto;
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* IE/Edge */
    }
    /* Hide webkit scrollbars visually while keeping scroll behavior */
    .card .bd .table::-webkit-scrollbar { display: none; height: 0; width: 0; }
    /* rights highlight */
    .pending-right { background: linear-gradient(180deg, rgba(255,50,50,0.06), rgba(255,50,50,0.02)); border:1px solid rgba(255,50,50,0.12); }
    .done-right { background: rgba(255,255,255,0.02); color: rgba(255,255,255,0.7); }
    #sellerRightsSection .btn{ margin-left:8px }
    #sellerRightsSection::-webkit-scrollbar { display: none; }

    #emphasis-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
    #emphasis-modal-content {
        background-color: var(--bg2);
        color: var(--text);
        padding: 40px;
        border-radius: 16px;
        border: 2px solid var(--accent-color);
        max-width: 80%;
        max-height: 80%;
        overflow-y: auto;
        position: relative;
        box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    #emphasis-modal-content .close-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        background: var(--red);
        color: white;
        border: none;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        font-size: 20px;
        line-height: 30px;
        text-align: center;
        cursor: pointer;
    }

    #balance-display {
        position: fixed;
        bottom: 16px;
        left: 16px;
        background-color: var(--panel);
        border: 1px solid var(--accent-color);
        border-radius: 12px;
        padding: 10px 15px;
        box-shadow: 0 5px 20px rgba(0,0,0,0.4);
        z-index: 99;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        transition: opacity 0.3s, transform 0.3s;
    }
    #balance-display span {
        font-size: 12px;
        color: var(--fg-muted);
        margin-bottom: 4px;
    }
    #balance-display strong {
        font-size: 18px;
        font-weight: 800;
        color: var(--green);
    }
</style>

</head>
<body>
<header>
    <div class="nav">
        <div style="display:flex;gap:10px;align-items:center">
            <div style="width:28px;height:28px;border-radius:8px;background:conic-gradient(from 200deg,#15c7b6,#60efff)"></div>
            trpg鯖 トークン<span class="chip">ローカル保存 & ルーム同期（KV）</span></div>
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <div id="userBadge" class="chip">未ログイン</div>
            <div id="streakBadge" class="chip">🔥0</div>
            <div id="jackpotBadge" class="chip">JPOT: 0</div>
            <button class="btn" id="morningBtn">朝活</button>
            <button class="btn secondary" id="exportBtn">エクスポート</button>
            <label class="btn secondary">インポート<input id="importFile" type="file" accept="application/json"
                                                          style="display:none"/></label></div>
    </div>
</header>
<main>
    <div class="grid">
        <section class="card">
            <div class="hd"><h3>アカウント & 同期</h3></div>
            <div class="bd">
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px">
                    <div class="panel">
                        <div class="chip">総ユーザー</div>
                        <div id="kpiMembers" style="font-weight:800">0</div>
                    </div>
                    <div class="panel">
                        <div class="chip">総供給量</div>
                        <div id="kpiSupply" style="font-weight:800">0 coin</div>
                    </div>
                </div>
                <button id="toggleSync">同期設定を表示</button>
                <div class="panel" id="syncPanel">
                    <label>同期設定（HTTP API /state）</label>
                    <input id="syncUrl" type="text" placeholder="https://<your-worker>.workers.dev/state"
                           style="width:100%;margin:6px 0"/>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
                        <input id="syncRoom" type="text" placeholder="ルーム名（例：trpg）"/>
                        <input id="syncKey" type="text" placeholder="ルーム鍵（例：1）"/>
                    </div>
                    <div class="tabbar" style="margin-top:8px">
                        <button class="btn" id="btnConnect">開始/停止</button>
                        <button class="btn secondary" id="btnSyncNow">手動同期</button>
                        <span id="syncStatus" class="chip">停止中</span></div>
                    <div id="lastSyncChip" class="chip" style="margin-top:6px">最終同期：—</div>
                </div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px">
                    <div class="panel">
                        <label>ログイン</label>
                        <input id="loginName" type="text" placeholder="ユーザー名"/><input id="loginPass"
                                                                                           type="password"
                                                                                           placeholder="パスワード"/>
                        <div class="tabbar">
                            <button class="btn" id="loginBtn">ログイン</button>
                            <button class="btn secondary" id="logoutBtn">ログアウト</button>
                        </div>
                    </div>
                    <div class="panel">
                        <label>新規登録（初期 10,000 coin）</label>
                        <input id="regName" type="text" placeholder="ユーザー名"/><input id="regPass" type="password"
                                                                                         placeholder="パスワード"/>
                        <button class="btn" id="registerBtn">登録</button>
                    </div>
                </div>
                <div class="panel" style="margin-top:8px"><label>ウォレット一覧</label>
                    <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:6px">
                        <div style="font-size:13px;color:var(--muted);">保有ウォレット</div>
                        <div>
                            <button id="walletToggleBtn" class="btn secondary" style="padding:6px 8px">折りたたむ</button>
                        </div>
                    </div>
                    <div id="walletList" style="display:grid;gap:6px"></div>
                </div>
            </div>
        </section>
        <section class="card">
            <div class="hd"><h3>操作</h3>
                <div class="tabbar">
                    <div class="tab active" data-tab="transfer">送金</div>
                    <div class="tab" data-tab="market">マーケット</div>
                    <div class="tab" data-tab="myrights">自分の権利</div>
                    <div class="tab" data-tab="gamble">ギャンブル</div>
                </div>
            </div>
            <div class="bd">
                <div id="tab-transfer">
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
                        <div class="panel"><label>送信元（あなた）</label><input id="fromFixed" type="text" disabled
                                                                               placeholder="未ログイン"/></div>
                        <div class="panel"><label>送信先</label><select id="toSelect"></select></div>
                    </div>
                    <div style="display:grid;grid-template-columns:1fr 140px;gap:10px;margin-top:8px">
                        <div class="panel"><label>金額（coin）</label><input id="amountInput" type="number" min="1"
                                                                           step="1" placeholder="例）250"/></div>
                        <div class="panel"><label>&nbsp;</label>
                            <button class="btn" id="sendBtn">送信する</button>
                        </div>
                    </div>
                    <div class="panel" style="margin-top:8px"><label>メモ（任意）</label><input id="memoInput" type="text"
                                                                                              placeholder="例）ギルド賞金"/>
                    </div>
                </div>
                <div id="tab-market" style="display:none;max-width:100%;overflow-x:hidden">
                    <div class="tabbar" style="margin-bottom:6px">
                        <div class="tab active" data-sub="sell">出品する</div>
                        <div class="tab" data-sub="list">出品一覧</div>
                    </div>
                    <div id="market-sell" class="panel">
                        <label>権利の出品</label><input id="listTitle" type="text" placeholder="例）ゲームを一緒に遊ぶ"/><textarea
                            id="listDesc" rows="2" placeholder="説明（任意）"></textarea>
                        <div style="display:grid;grid-template-columns:1fr 1fr 140px;gap:8px">
                            <div><label>価格</label><input id="listPrice" type="number" min="1" step="1"/></div>
                            <div><label>在庫</label><input id="listQty" type="number" min="1" step="1"/></div>
                            <div style="display:flex;align-items:end">
                                <button class="btn" id="createListingBtn">出品する</button>
                            </div>
                        </div>
                    </div>
                    <div id="market-list" style="display:none">
                        <div class="table">
                            <table>
                                <thead>
                                <tr>
                                    <th>タイトル</th>
                                    <th>価格</th>
                                    <th>在庫</th>
                                    <th>出品者</th>
                                    <th>説明</th>
                                    <th>操作</th>
                                </tr>
                                </thead>
                                <tbody id="listingBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
                <div id="tab-myrights" style="display:none">
                    <div class="table">
                        <table>
                            <thead>
                            <tr>
                                <th>日付</th>
                                <th>タイトル</th>
                                <th>販売者</th>
                                <th>状態</th>
                                <th>操作</th>
                            </tr>
                            </thead>
                            <tbody id="rightsBody"></tbody>
                        </table>
                    </div>
                                <div style="margin-top:12px">
                                    <h4 style="margin:6px 0 8px">出品された権利（販売者用）</h4>
                                    <div id="sellerRightsSection" class="panel" style="max-height:400px;overflow-y:auto;padding:8px; scrollbar-width: none; -ms-overflow-style: none;"></div>
                                </div>
                </div>
                <div id="tab-gamble" style="display:none">
                    <div class="panel"><label>TRPGジャックポット</label>
                        <div class="tabbar">
                            <div class="chip" id="jackpotChip">現在: 0 coin</div>
                        </div>
                    </div>
                    <div class="panel"><h4 style="margin:0">🎰 ルーレット（1回100 coin）</h4>
                        <p style="margin:0;color:#94a3b8;font-size:12px">期待値約70%。1%で全額ジャックポット。</p>
                        <div class="tabbar">
                            <button class="btn" id="rouletteBtn">回す</button>
                        </div>
                        <div id="rouletteResult" class="chip" style="margin-top:8px">結果: —</div>
                    </div>
                </div>
                <div class="toast" id="toast"></div>
            </div>
        </section>
        <section class="card">
            <div class="hd"><h3>履歴</h3>
                <div class="tabbar"><input id="searchInput" type="text" placeholder="検索：名前 / メモ / 権利"
                                           style="width:200px"/><select id="memberFilter">
                    <option value="">すべて</option>
                </select>
                    <div id="lastActivity" class="chip">最終更新：—</div>
                    <button id="compactLogBtn" class="btn secondary" style="margin-left:8px">ログ: コンパクト</button>
                </div>
            </div>
            <div class="bd">
                <div class="table">
                    <table>
                        <thead>
                        <tr>
                            <th>日付</th>
                            <th>種別</th>
                            <th>送信元/販売者</th>
                            <th>送信先/購入者</th>
                            <th>メモ/権利</th>
                            <th style="text-align:right">金額</th>
                        </tr>
                        </thead>
                        <tbody id="historyBody"></tbody>
                    </table>
                </div>
            </div>
        </section>
    </div>
</main>

<script>
    (function () {
        const LS_KEY = 'trpg_token_state_v14_kv', INITIAL_BAL = 10000, JACKPOT_NAME = 'ジャックポット';
        let state = {
            users: [],
            txs: [],
            listings: [],
            rights: [],
            currentUserId: null,
            jackpotUserId: '',
            lastRealUserId: null,
            approval: {active: false, votes: {}},
            version: 14,
            vTick: 0
        };
        const els = {
            kpiMembers: document.getElementById('kpiMembers'),
            kpiSupply: document.getElementById('kpiSupply'),
            walletList: document.getElementById('walletList'),
            toSelect: document.getElementById('toSelect'),
            sendBtn: document.getElementById('sendBtn'),
            amountInput: document.getElementById('amountInput'),
            memoInput: document.getElementById('memoInput'),
            historyBody: document.getElementById('historyBody'),
            searchInput: document.getElementById('searchInput'),
            memberFilter: document.getElementById('memberFilter'),
            exportBtn: document.getElementById('exportBtn'),
            importFile: document.getElementById('importFile'),
            lastActivity: document.getElementById('lastActivity'),
            userBadge: document.getElementById('userBadge'),
            fromFixed: document.getElementById('fromFixed'),
            streakBadge: document.getElementById('streakBadge'),
            jackpotBadge: document.getElementById('jackpotBadge'),
            morningBtn: document.getElementById('morningBtn'),
            loginName: document.getElementById('loginName'),
            loginPass: document.getElementById('loginPass'),
            loginBtn: document.getElementById('loginBtn'),
            logoutBtn: document.getElementById('logoutBtn'),
            regName: document.getElementById('regName'),
            regPass: document.getElementById('regPass'),
            registerBtn: document.getElementById('registerBtn'),
            tabs: Array.from(document.querySelectorAll('.tabbar .tab')),
            tabTransfer: document.getElementById('tab-transfer'),
            tabMarket: document.getElementById('tab-market'),
            tabMyRights: document.getElementById('tab-myrights'),
            tabGamble: document.getElementById('tab-gamble'),
            listTitle: document.getElementById('listTitle'),
            listDesc: document.getElementById('listDesc'),
            listPrice: document.getElementById('listPrice'),
            listQty: document.getElementById('listQty'),
            createListingBtn: document.getElementById('createListingBtn'),
            listingBody: document.getElementById('listingBody'),
            rightsBody: document.getElementById('rightsBody'),
            subtabs: Array.from(document.querySelectorAll('#tab-market .tab')),
            marketSell: document.getElementById('market-sell'),
            marketList: document.getElementById('market-list'),
            jackpotChip: document.getElementById('jackpotChip'),
            rouletteBtn: document.getElementById('rouletteBtn'),
            rouletteResult: document.getElementById('rouletteResult'),
            syncUrl: document.getElementById('syncUrl'),
            syncRoom: document.getElementById('syncRoom'),
            syncKey: document.getElementById('syncKey'),
            toggleSync: document.getElementById('toggleSync'),
            syncPanel: document.getElementById('syncPanel'),
            btnConnect: document.getElementById('btnConnect'),
            btnSyncNow: document.getElementById('btnSyncNow'),
            syncStatus: document.getElementById('syncStatus'),
            lastSyncChip: document.getElementById('lastSyncChip')
        };
        const fmt = new Intl.NumberFormat('ja-JP');
        const coins = n => fmt.format(n) + ' coin';
        const ts2str = ts => {
            const d = new Date(ts);
            const y = d.getFullYear(), m = String(d.getMonth() + 1).padStart(2, '0'),
                day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`
        };
        const id = () => Math.random().toString(36).slice(2) + Date.now().toString(36);

        function toast(msg) {
            const t = document.getElementById('toast');
            const div = document.createElement('div');
            div.className = 'chip';
            div.textContent = msg;
            t.appendChild(div);
            setTimeout(() => div.remove(), 2500);
        }

        // Persist only minimal local session info (currentUserId). Full state lives on server.
        function saveLocal() {
            try {
                localStorage.setItem('last_current_uid', state.currentUserId || '');
            } catch (e) {
                console.warn('saveLocal failed', e);
            }
        }

        // In server-side mode we don't schedule local pushes; operations are sent immediately.
        function schedulePush() {
            // no-op (kept for compatibility)
        }

        function loadLocal() {
            try {
                const last = localStorage.getItem('last_current_uid');
                if (last) state.currentUserId = last || null;
            } catch (e) {
                console.warn('loadLocal failed', e);
            }
            if (typeof state.vTick !== 'number') state.vTick = 0;
        }

        const syncStoreKey = 'trpg_sync_kv';
        let syncSettings = {url: '', room: '', key: ''};

        function loadSyncSettings() {
            try {
                const s = JSON.parse(localStorage.getItem(syncStoreKey) || '{}');
                syncSettings = Object.assign({url: '', room: '', key: ''}, s);
            } catch {
            }
            els.syncUrl.value = syncSettings.url;
            els.syncRoom.value = syncSettings.room;
            els.syncKey.value = syncSettings.key;

            // Setup toggle button
            els.toggleSync.addEventListener('click', () => {
                els.syncPanel.classList.toggle('expanded');
                els.toggleSync.textContent = els.syncPanel.classList.contains('expanded') ? '同期設定を隠す' : '同期設定を表示';
            });
        }

        function saveSyncSettings() {
            syncSettings = {
                url: els.syncUrl.value.trim(),
                room: els.syncRoom.value.trim(),
                key: els.syncKey.value.trim()
            };
            localStorage.setItem(syncStoreKey, JSON.stringify(syncSettings));
        }

        // 既存scriptの同期関連部分を以下で置き換え
        // 操作キュー方式：クライアントは操作をキューに入れ、PUT /state に operations 配列を送る
    let pendingOperations = []; // 送信待ちの操作
    let lastSyncTime = 0; // サーバー側の lastUpdate を記録
    let operationQueue = []; // 操作キュー（履歴的に残す）
    let isSyncing = false;
    // Separate timers: one for pushing pending ops, one for fetching latest state
    let pushTimer = null;
    let fetchTimer = null;
        // Applied operation ids to avoid double-applying from BroadcastChannel + server
        const appliedOpIds = new Set();
        const processedNotifIds = new Set();

        function showNotification(notif) {
            if (processedNotifIds.has(notif.id)) return;
            processedNotifIds.add(notif.id);

            if (notif.type === 'emphasis') {
                const modal = document.getElementById('emphasis-modal');
                const content = document.getElementById('emphasis-modal-content');

                let modalHTML = notif.isHtml ? notif.content : `<p>${notif.content}</p>`;
                modalHTML += '<button class="close-btn">&times;</button>';
                content.innerHTML = modalHTML;

                modal.style.display = 'flex';

                content.querySelector('.close-btn').onclick = () => {
                    modal.style.display = 'none';
                };
            } else {
                // 'normal' or default
                toast(notif.content);
            }
        }

        // BroadcastChannel for intra-browser-tab communication
        let bc = null;
        try {
            bc = new BroadcastChannel('trpg_sync');
        bc.addEventListener('message', (event) => {
                const msg = event.data || {};
                if (!msg || !msg.type) return;
                // ignore own tab's messages
                if (msg.sessionId === getSessionId()) return;

                if (msg.type === 'operation_queued' && msg.operation) {
                    // Prevent applying same op twice
                    if (appliedOpIds.has(msg.operation.id)) return;
                    appliedOpIds.add(msg.operation.id);
                    try {
                        applyOperationLocally(msg.operation);
                    } catch (e) { console.error('BC apply error', e); }
                    renderAll();
            // Try to fetch latest from server so users/txs and authoritative state propagate quickly
            // (no-op if sync not configured)
            kvFetchLatest().catch(() => {});
                }
            });
        } catch (e) {
            console.warn('BroadcastChannel not available', e);
            bc = null;
        }

        // 操作を生成する共通関数
        function createOperation(type, data, userId = null) {
            const operation = {
                id: generateOperationId(),
                type: type,
                data: data,
                timestamp: Date.now(), // ミリ秒単位のタイムスタンプ
                userId: userId || state.currentUserId,
                clientId: getClientId(), // クライアント識別用
                sessionId: getSessionId() // タブ（セッション）識別用
            };
            
            console.log('Creating operation:', operation);
            return operation;
        }

        // タブ単位のセッションID（sessionStorage とは別に window プロパティで保持）
        function getSessionId() {
            if (window.__trpg_session_id) return window.__trpg_session_id;
            const sid = 'session_' + Math.random().toString(36).slice(2) + '_' + Date.now();
            window.__trpg_session_id = sid;
            return sid;
        }

        function generateOperationId() {
            return 'op_' + Math.random().toString(36).slice(2) + '_' + Date.now() + '_' + Math.random().toString(36).slice(2);
        }

        function getClientId() {
            let clientId = localStorage.getItem('trpg_client_id');
            if (!clientId) {
                clientId = 'client_' + Math.random().toString(36).slice(2) + '_' + Date.now();
                localStorage.setItem('trpg_client_id', clientId);
            }
            return clientId;
        }

        // 操作をキューに追加
        function queueOperation(operation) {
            operationQueue.push(operation);
            pendingOperations.push(operation);
            
            // Broadcast to other tabs so they can optimistic-update too
            try {
                if (bc) bc.postMessage({ type: 'operation_queued', operation: operation, sessionId: getSessionId() });
            } catch (e) { console.warn('BC post failed', e); }

            // In server-side mode, send operation immediately and update UI from server response
            appliedOpIds.add(operation.id);
            // show optimistic indicator locally, but do not persist full state locally
            applyOperationLocally(operation);
            // fire-and-handle response for user feedback
            (async () => {
                const res = await sendOperationsToServer([operation]);
                if (!res.ok) {
                    console.error('sendOperationsToServer error', res.error);
                    toast('操作の送信に失敗しました: ' + (res.error || '通信エラー'));
                    return;
                }
                const d = res.data || {};
                if (d.conflicts && d.conflicts.length) {
                    toast('サーバーで競合が発生しました: ' + (d.conflicts[0].message || d.conflicts[0].type));
                } else {
                    // inspect notify for refund details
                    const notify = d.notify || {};
                    // If there are newTxs indicating seller_refund, show detailed message
                    const txs = (notify.newTxs || []).slice();
                    const refundTx = txs.find(t => t && t.type === 'seller_refund');
                    let msgShown = false;
                    if (refundTx) {
                        const amt = refundTx.amount || 0;
                        const listingId = refundTx.listingId || '';
                        // check if listing was updated in notify
                        const updatedListings = notify.updatedListings || [];
                        const recovered = updatedListings.find(l => l.id === listingId && l.sold < (l.qty || 1));
                        const recoveredMsg = recovered ? '、出品在庫が回復しました' : '';
                        toast(`返金成功: ¥${amt}${recoveredMsg}`);
                        msgShown = true;
                    }
                    if (!msgShown) {
                        toast('操作がサーバーで処理されました');
                    }
                }
            })();
        }

        // Immediately send operations to server and apply returned newState
        async function sendOperationsToServer(ops) {
            if (!syncSettings.url || !syncSettings.room || !syncSettings.key) {
                // no server configured
                return { ok: false, error: 'no sync configured' };
            }
            const u = new URL(syncSettings.url);
            u.searchParams.set('room', syncSettings.room);
            u.searchParams.set('key', syncSettings.key);

            try {
                const res = await fetch(u.toString(), { method: 'PUT', headers: {'content-type':'application/json'}, body: JSON.stringify({ operations: ops }) });
                if (!res.ok) {
                    const txt = await res.text().catch(() => '');
                    return { ok: false, error: txt || res.status };
                }
                const data = await res.json().catch(() => null);
                if (data && data.newState) {
                    const keep = state.currentUserId;
                    state = data.newState;
                    state.currentUserId = keep || null;
                    lastSyncTime = data.lastUpdate || Date.now();
                    renderAll();
                    saveLocal();
                }
                if (data && Array.isArray(data.processedOps)) {
                    const processedIds = new Set(data.processedOps.map(p => p));
                    pendingOperations = pendingOperations.filter(op => !processedIds.has(op.id));
                }
                if (data && data.conflicts && data.conflicts.length) handleConflicts(data.conflicts);
                return { ok: true, data };
            } catch (e) {
                console.error('sendOperationsToServer failed', e);
                return { ok: false, error: e.message };
            }
        }

        // ローカルで操作を適用（楽観的更新） — 全操作はここで処理する
        function applyOperationLocally(operation) {
            console.log('Applying operation locally:', operation);
            const { type, data, timestamp, userId } = operation;

            switch (type) {
                case 'transfer': {
                    const from = findUserById(userId);
                    const to = findUserById(data.toId);
                    if (!from || !to) break;
                    // 基本的に呼び出し元でバリデーション済みのはず
                    from.balance = (from.balance || 0) - data.amount;
                    to.balance = (to.balance || 0) + data.amount;
                    addTx({ type: 'transfer', from: from.id, to: to.id, amount: data.amount, memo: data.memo || '', pending: true, ts: timestamp || Date.now() });
                    break;
                }

                case 'buy_listing': {
                    const listing = state.listings.find(l => l.id === data.listingId && l.active);
                    const buyer = findUserById(userId);
                    if (!listing || !buyer) break;
                    const seller = findUserById(listing.sellerId);
                    const fee = Math.floor(listing.price * 0.10);
                    const sellerReceive = listing.price - fee;
                    buyer.balance = (buyer.balance || 0) - listing.price;
                    if (seller) seller.balance = (seller.balance || 0) + sellerReceive;
                    const j = jackpotUser(); if (j) j.balance = (j.balance || 0) + fee;
                    listing.sold = (listing.sold || 0) + 1;
                    if (listing.sold >= (listing.qty || 1)) listing.active = false;
                    const right = { id: id(), listingId: listing.id, title: listing.title, buyerId: buyer.id, sellerId: listing.sellerId, ts: timestamp || Date.now(), status: 'owned', executed: false, pending: true };
                    state.rights.unshift(right);
                    addTx({ type: 'purchase', from: buyer.id, to: listing.sellerId, amount: listing.price, listingId: listing.id, title: listing.title, memo: '権利購入（手数料10%）', pending: true, ts: timestamp || Date.now() });
                    break;
                }

                case 'create_listing': {
                    const l = {
                        id: data.listingId || id(),
                        title: data.title,
                        price: data.price,
                        desc: data.desc || '',
                        sellerId: userId || state.currentUserId,
                        active: true,
                        ts: timestamp || Date.now(),
                        qty: data.qty || 1,
                        sold: 0,
                        pending: true
                    };
                    state.listings.unshift(l);
                    break;
                }

                case 'delete_listing': {
                    const idx = state.listings.findIndex(x => x.id === data.listingId);
                    if (idx !== -1) state.listings.splice(idx, 1);
                    break;
                }

                case 'toggle_listing': {
                    const l = state.listings.find(x => x.id === data.listingId);
                    if (l) l.active = !l.active;
                    break;
                }

                case 'register_user': {
                    const { name, passHash } = data;
                    if (state.users.some(u => u.name === name)) break;
                    const newUser = { id: id(), name, passHash, balance: INITIAL_BAL, streakCount: 0, lastMorningDate: '', pending: true };
                    state.users.push(newUser);
                    break;
                }

                case 'morning_claim': {
                    const me = findUserById(userId);
                    if (!me) break;
                    const today = data.date || ts2str(Date.now());
                    if (me.lastMorningDate) {
                        const diff = Math.round((new Date(today) - new Date(me.lastMorningDate)) / 86400000);
                        me.streakCount = (diff === 1) ? Math.min((me.streakCount || 0) + 1, STREAK_MAX) : 1;
                    } else {
                        me.streakCount = 1;
                    }
                    me.lastMorningDate = today;
                    const bonus = MORNING_BASE + STREAK_INC * (me.streakCount || 0);
                    me.balance = (me.balance || 0) + bonus;
                    addTx({ type: 'mint', to: me.id, amount: bonus, memo: `朝活（連続${me.streakCount}日）`, pending: true, ts: timestamp || Date.now() });
                    break;
                }

                case 'roulette': {
                    // クライアント側で楽観的に参加費を支払っている前提
                    const me = findUserById(userId);
                    const j = jackpotUser();
                    if (!me || !j) break;
                    // サーバー側で最終的な当選判定されるためここでは参加費のみ
                    addTx({ type: 'jpot-fee', from: me.id, to: j.id, amount: 100, memo: 'ルーレット参加費', pending: true, ts: timestamp || Date.now() });
                    break;
                }

                default:
                    console.warn('Unknown operation type in applyOperationLocally:', type);
            }

            bump();
            renderAll();
        }

        // 競合通知の簡易処理
        function handleConflicts(conflicts) {
            if (!Array.isArray(conflicts) || conflicts.length === 0) return;
            state.conflicts = state.conflicts || [];
            for (const c of conflicts) {
                state.conflicts.push(c);
                toast('競合検出: ' + (c.message || c.type || 'unknown'));
            }
            saveLocal(true);
        }

        // 修正された送金関数（既存の transfer をキュー方式へ差し替え）
        async function transfer(toId, amount, memo) {
            const from = currentUser();
            if (!from) {
                toast('ログインが必要');
                return;
            }
            
            amount = Math.floor(Number(amount));
            if (!(amount > 0)) {
                toast('金額は1以上の整数');
                return;
            }
            
            const to = findUserById(toId);
            if (!to) {
                toast('送信先が不正');
                return;
            }
            
            if (from.id === toId) {
                toast('自分自身へは送れません');
                return;
            }
            
            if (from.balance < amount) {
                toast('残高不足');
                return;
            }

            // 操作をキューに追加
            const operation = createOperation('transfer', {
                toId: toId,
                amount: amount,
                memo: memo || ''
            });
            
            queueOperation(operation);
            
            // ローカルで即座に実行（楽観的更新）
            from.balance -= amount;
            to.balance += amount;
            addTx({
                type: 'transfer',
                from: from.id,
                to: to.id,
                amount,
                memo: (memo || '').trim(),
                pending: true // ペンディング状態をマーク
            });
            
            saveLocal(true); // 同期はschedulePushで行う
        }

        // 出品購入の修正版
        async function buyListing(listingId) {
            const buyer = currentUser();
            if (!buyer) {
                toast('ログインが必要');
                return;
            }
            
            const listing = state.listings.find(x => x.id === listingId && x.active);
            if (!listing) {
                toast('出品が見つかりません');
                return;
            }

            // 操作をキューに追加
            const operation = createOperation('buy_listing', {
                listingId: listingId
            });
            
            queueOperation(operation);
            
            // ローカルで楽観的更新
            const remaining = (listing.qty || 1) - (listing.sold || 0);
            if (remaining > 0 && buyer.balance >= listing.price) {
                const seller = findUserById(listing.sellerId);
                const j = jackpotUser();
                const fee = Math.floor(listing.price * 0.10);
                const sellerReceive = listing.price - fee;
                
                buyer.balance -= listing.price;
                seller.balance += sellerReceive;
                j.balance += fee;
                
                listing.sold = (listing.sold || 0) + 1;
                if (listing.sold >= listing.qty) {
                    listing.active = false;
                }
                
                // 権利とトランザクションを追加
                const right = {
                    id: id(),
                    listingId: listing.id,
                    title: listing.title,
                    buyerId: buyer.id,
                    sellerId: seller.id,
                    ts: operation.timestamp,
                    status: 'owned',
                    executed: false,
                    pending: true
                };
                state.rights.unshift(right);
                
                addTx({
                    type: 'purchase',
                    from: buyer.id,
                    to: seller.id,
                    amount: listing.price,
                    listingId: listing.id,
                    title: listing.title,
                    memo: '権利購入（手数料10%）',
                    pending: true
                });
            }
            
            saveLocal(true);
        }

        // ユーザー登録の修正版
        async function register(name, pass) {
            name = (name || '').trim();
            if (!name || !pass) {
                toast('ユーザー名とパスワードを入力');
                return;
            }
            
            if (name === 'ジャックポット') {
                toast('この名前は予約されています');
                return;
            }
            
            if (state.users.some(u => u.name === name)) {
                toast('そのユーザー名は使用済み');
                return;
            }
            
            const passHash = await sha256(pass);
            
            // 操作をキューに追加
            const operation = createOperation('register_user', {
                name: name,
                passHash: passHash
            }, null); // userIdはnull（新規登録なので）
            
            queueOperation(operation);
            
            // ローカルで楽観的更新
            const u = {
                id: id(),
                name,
                passHash,
                balance: 10000,
                streakCount: 0,
                lastMorningDate: '',
                pending: true
            };
            
            state.users.push(u);
            state.currentUserId = u.id;
            state.lastRealUserId = u.id;
            
            addTx({
                type: 'mint',
                to: u.id,
                amount: 10000,
                memo: '初期発行',
                pending: true
            });
            
            saveLocal(true);
            toast('登録処理中...');
        }

        // 朝活の修正版
        function morningClaim() {
            const me = currentUser();
            const check = canClaimMorning();
            if (!check.ok) {
                toast(check.reason);
                return;
            }

            // 操作をキューに追加
            const operation = createOperation('morning_claim', {
                date: todayKey()
            });
            
            queueOperation(operation);
            
            // ローカルで楽観的更新
            const today = todayKey();
            if (me.lastMorningDate) {
                const diff = Math.round((new Date(today) - new Date(me.lastMorningDate)) / 86400000);
                me.streakCount = (diff === 1) ? Math.min((me.streakCount || 0) + 1, 30) : 1;
            } else {
                me.streakCount = 1;
            }
            
            me.lastMorningDate = today;
            const bonus = 1000 + 100 * (me.streakCount || 0);
            me.balance += bonus;
            
            addTx({
                type: 'mint',
                to: me.id,
                amount: bonus,
                memo: `朝活（連続${me.streakCount}日）`,
                pending: true
            });
            
            saveLocal(true);
        }

        // ルーレットの修正版
        function rouletteSpin() {
            const me = currentUser();
            if (!me || me.balance < 100) {
                toast('参加できません');
                return;
            }
            
            const roll = Math.random(); // クライアント側で乱数生成
            
            // 操作をキューに追加
            const operation = createOperation('roulette', {
                roll: roll
            });
            
            queueOperation(operation);
            
            // ローカルで楽観的更新（簡易版）
            me.balance -= 100;
            const j = jackpotUser();
            j.balance += 100;
            
            addTx({
                type: 'jpot-fee',
                from: me.id,
                to: j.id,
                amount: 100,
                memo: 'ルーレット参加費',
                pending: true
            });
            
            // 結果は一旦保留（サーバーレスポンス待ち）
            document.getElementById('rouletteResult').textContent = '結果: 処理中...';
            
            saveLocal(true);
        }

        // サーバーとの同期処理（worker.js の /state PUT を使う）
        // kvPushState replaced by sendOperationsToServer which sends immediately
        async function kvPushState() {
            // compatibility wrapper: send all pending synchronously
            if (pendingOperations.length === 0) return;
            const ops = [...pendingOperations];
            const r = await sendOperationsToServer(ops);
            if (r && r.ok) {
                // server handled them
            }
        }

        // サーバーから最新状態を取得（worker.js の GET /state を想定）
        async function kvFetchLatest() {
            if (!syncSettings.url || !syncSettings.room || !syncSettings.key) return;
            try {
                const u = new URL(syncSettings.url);
                u.searchParams.set('room', syncSettings.room);
                u.searchParams.set('key', syncSettings.key);
                u.searchParams.set('lastSync', String(lastSyncTime || 0));

                const res = await fetch(u.toString(), {method: 'GET', headers: {accept: 'application/json'}});
                if (res.status === 204) {
                    els.lastSyncChip.textContent = '最終同期：変更なし ' + new Date().toLocaleTimeString();
                    return;
                }
                if (!res.ok) return;

                const data = await res.json().catch(() => null);
                if (!data) return;

                // If server returns processedOps (what it has applied), remove them from pendingOperations
                if (Array.isArray(data.processedOps)) {
                    const processedIds = new Set(data.processedOps.map(p => p.id || p));
                    pendingOperations = pendingOperations.filter(op => !processedIds.has(op.id));
                }

                // Merge authoritative lists when server state is newer OR when server returned processedOps
                // (some server responses may include processedOps without bumping lastUpdate; handle both)
                if (data.state && ((data.lastUpdate && data.lastUpdate > (lastSyncTime || 0)) || (Array.isArray(data.processedOps) && data.processedOps.length))) {
                    const keep = state.currentUserId;
                    // Merge in important lists so clients stay consistent: users, txs, listings, rights
                    if (Array.isArray(data.state.users)) state.users = data.state.users;
                    if (Array.isArray(data.state.txs)) state.txs = data.state.txs;
                    if (Array.isArray(data.state.listings)) state.listings = data.state.listings;
                    if (Array.isArray(data.state.rights)) state.rights = data.state.rights;
                    // Also pick up a few small authoritative fields if present
                    if (data.state.jackpotUserId) state.jackpotUserId = data.state.jackpotUserId;
                    if (data.state.lastRealUserId) state.lastRealUserId = data.state.lastRealUserId;
                    state.vTick = typeof data.state.vTick === 'number' ? data.state.vTick : state.vTick;
                    state.currentUserId = keep || null;
                    saveLocal(true);
                    renderAll();
                    els.lastSyncChip.textContent = '最終同期：受信 ' + new Date().toLocaleTimeString();
                    lastSyncTime = data.lastUpdate || Date.now();
                }
                // server-side immediate notify: new users / new txs / rights / listing updates created by other clients
                if (data.notify) {
                    // merge new users (avoid duplicates)
                    if (Array.isArray(data.notify.newUsers) && data.notify.newUsers.length) {
                        for (const u of data.notify.newUsers) {
                            if (!state.users.some(x => x.id === u.id)) state.users.push(u);
                        }
                        // sort by insertion order (optional)
                        state.users.sort((a,b) => (a.ts||0) - (b.ts||0));
                    }
                    // merge new txs at head
                    if (Array.isArray(data.notify.newTxs) && data.notify.newTxs.length) {
                        for (const t of data.notify.newTxs) {
                            if (!state.txs.some(x => x.id === t.id)) state.txs.unshift(t);
                        }
                    }
                    // merge new rights
                    if (Array.isArray(data.notify.newRights) && data.notify.newRights.length) {
                        for (const r of data.notify.newRights) {
                            if (!state.rights.some(x => x.id === r.id)) state.rights.unshift(r);
                        }
                    }
                    // merge updated listings by id
                    if (Array.isArray(data.notify.updatedListings) && data.notify.updatedListings.length) {
                        for (const up of data.notify.updatedListings) {
                            const idx = state.listings.findIndex(x => x.id === up.id);
                            if (idx !== -1) state.listings[idx] = up; else state.listings.unshift(up);
                        }
                    }
                    // merge updated rights by id
                    if (Array.isArray(data.notify.updatedRights) && data.notify.updatedRights.length) {
                        for (const up of data.notify.updatedRights) {
                            const idx = state.rights.findIndex(x => x.id === up.id);
                            if (idx !== -1) state.rights[idx] = up; else state.rights.unshift(up);
                        }
                    }
                    // remove deleted listings
                    if (Array.isArray(data.notify.deletedListings) && data.notify.deletedListings.length) {
                        for (const delId of data.notify.deletedListings) {
                            const idx = state.listings.findIndex(x => x.id === delId);
                            if (idx !== -1) state.listings.splice(idx, 1);
                        }
                    }
                     // Handle system messages (new per-user method)
                    const me = currentUser();
                    if (me && Array.isArray(me.pendingMessages) && me.pendingMessages.length) {
                        for (const notif of me.pendingMessages) {
                            showNotification(notif);
                        }
                        // After showing, send an op to clear them from the server
                        queueOperation(createOperation('clear_my_messages', {}));
                    }
                    renderAll();
                }

                if (data.conflicts && data.conflicts.length) {
                    handleConflicts(data.conflicts);
                }
            } catch (e) {
                console.error('kvFetchLatest error', e);
            }
        }

        // Listen to localStorage changes from other tabs and reconcile
        window.addEventListener('storage', (e) => {
            try {
                if (e.key !== LS_KEY) return;
                if (!e.newValue) return;
                const newState = JSON.parse(e.newValue);
                if (!newState) return;
                const keep = state.currentUserId;
                state = newState;
                state.currentUserId = keep || null;
                // prevent appliedOpIds from growing unbounded
                if (appliedOpIds.size > 5000) {
                    appliedOpIds.clear();
                }
                renderAll();
            } catch (err) {
                console.error('storage event handling error', err);
            }
        });

        async function sha256(text) {
            const enc = new TextEncoder().encode(text);
            const buf = await crypto.subtle.digest('SHA-256', enc);
            return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function findUserById(uid) {
            return state.users.find(u => u.id === uid) || null;
        }

        function findUserByName(name) {
            return state.users.find(u => u.name === name) || null;
        }

        function jackpotUser() {
            return findUserById(state.jackpotUserId);
        }

        function isJackpot(u) {
            return u && u.id === state.jackpotUserId;
        }

        function nameOf(uid) {
            const u = findUserById(uid);
            return u ? u.name : '';
        }

        function ensureJackpotUser() {
            let j = findUserByName(JACKPOT_NAME);
            if (!j) {
                j = {id: id(), name: JACKPOT_NAME, passHash: '', balance: 0, streakCount: 0, lastMorningDate: ''};
                state.users.unshift(j);
            }
            state.jackpotUserId = j.id;
        }

        function addTx(obj) {
            const base = {id: id(), ts: Date.now()};
            state.txs.unshift(Object.assign(base, obj));
        }

        function bump() {
            state.vTick = (state.vTick || 0) + 1;
        }

    // duplicate register removed — registration is handled earlier via createOperation + queueOperation

        async function login(name, pass) {
            name = (name || '').trim();
            const u = findUserByName(name);
            if (!u) {
                toast('ユーザーが見つかりません');
                return;
            }
            if (isJackpot(u)) {
                state.currentUserId = u.id;
            } else {
                const passHash = await sha256(pass || '');
                if (u.passHash !== passHash) {
                    toast('パスワードが違います');
                    return;
                }
                state.currentUserId = u.id;
                state.lastRealUserId = u.id;
            }
            localStorage.setItem('last_current_uid', state.currentUserId || '');
            saveLocal(true);
            renderAll();
            // sync client removed: subsequent operations will use state.currentUserId
            toast('ログイン');
            // Remind user about any unfinalized executions (buyer or seller side)
            try {
                remindUnfinalizedExecutions(state.currentUserId);
            } catch (e) { console.warn('remind error', e); }
        }

        function remindUnfinalizedExecutions(userId) {
            if (!userId) return;
            const buyerPending = state.rights.filter(r => r.buyerId === userId && r.status && r.status !== 'finalized');
            const sellerRequests = state.rights.filter(r => r.sellerId === userId && r.status === 'request');
            if (buyerPending.length) {
                toast(`未確定の実行が ${buyerPending.length} 件あります。履歴または権利一覧を確認してください`);
            }
            if (sellerRequests.length) {
                toast(`対応待ちの実行申請が ${sellerRequests.length} 件あります。権利一覧で応答してください`);
            }
        }

        function logout() {
            state.currentUserId = null;
            localStorage.setItem('last_current_uid', '');
            saveLocal(true);
            renderAll();
            // sync client removed: nothing to reflect here
            toast('ログアウト');
        }

        function currentUser() {
            return findUserById(state.currentUserId);
        }

        async function transfer(toId, amount, memo) {
            const from = currentUser();
            if (!from) {
                toast('ログインが必要');
                return;
            }
            amount = Math.floor(Number(amount));
            if (!(amount > 0)) {
                toast('金額は1以上の整数');
                return;
            }
            const to = findUserById(toId);
            if (!to) {
                toast('送信先が不正');
                return;
            }
            if (from.id === toId) {
                toast('自分自身へは送れません');
                return;
            }
            if (isJackpot(to)) {
                toast('ジャックポットへは直接送金できません');
                return;
            }
            if (from.balance < amount) {
                toast('残高不足');
                return;
            }

            // legacy OperationBasedSync removed — use queue-based createOperation + queueOperation
            const operation = createOperation('transfer', { toId: to.id, amount: amount, memo: (memo || '').trim() });
            queueOperation(operation);
            // optimistic update already applied in the other transfer implementation
            return;
        }

    async function createListing(title, price, desc) {
            const seller = currentUser();
            if (!seller) {
                toast('ログインが必要');
                return;
            }
            if (isJackpot(seller)) {
                toast('JPOTでは出品不可');
                return;
            }
            title = (title || '').trim();
            desc = (desc || '').trim();
            price = Math.floor(Number(price));
          let qty = Math.floor(Number((els.listQty && els.listQty.value) || 1));
            if (!title || !(price > 0) || !(qty > 0)) {
                toast('入力を確認');
                return;
            }
            const operation = createOperation('create_listing', {
                title, price, desc, qty,
                listingId: `listing_${Date.now()}_${Math.random().toString(36).substr(2,6)}`
            });
            queueOperation(operation);

            // optimistic local apply
            const l = {id: id(), title, price, desc, sellerId: seller.id, active: true, ts: Date.now(), qty, sold: 0, pending: true};
            state.listings.unshift(l);
            bump();
            saveLocal(true);
            renderAll();
        }

    async function buyListing(listingId) {
            const buyer = currentUser();
            if (!buyer) {
                toast('ログインが必要');
                return;
            }
            const l = state.listings.find(x => x.id === listingId && x.active);
            if (!l) {
                toast('出品が見つかりません');
                return;
            }
            if (l.sellerId === buyer.id) {
                toast('自分の出品は購入不可');
                return;
            }
            if (isJackpot(buyer)) {
                toast('JPOTでは購入不可');
                return;
            }
            const remaining = (l.qty || 1) - (l.sold || 0);
            if (remaining <= 0) {
                toast('在庫切れ');
                l.active = false;
                bump();
                saveLocal();
                renderAll();
                return;
            }
            if (buyer.balance < l.price) {
                toast('残高不足');
                return;
            }
            const operation = createOperation('buy_listing', { listingId: l.id });
            queueOperation(operation);

            // optimistic local apply (already implemented earlier in the file, but keep safe here)
            const seller = findUserById(l.sellerId);
            const j = jackpotUser();
            const fee = Math.floor(l.price * 0.10);
            const sellerReceive = l.price - fee;
            buyer.balance -= l.price;
            if (seller) seller.balance += sellerReceive;
            if (j) j.balance += fee;
            const right = {
                id: id(),
                listingId: l.id,
                title: l.title,
                buyerId: buyer.id,
                sellerId: seller ? seller.id : l.sellerId,
                ts: Date.now(),
                status: 'owned',
                executed: false,
                pending: true
            };
            state.rights.unshift(right);
            l.sold = (l.sold || 0) + 1;
            if (l.sold >= l.qty) {
                l.active = false;
            }
            addTx({ type: 'purchase', from: buyer.id, to: seller ? seller.id : l.sellerId, amount: l.price, listingId: l.id, title: l.title, memo: '権利購入（手数料10%）', pending: true });
            addTx({ type: 'fee', from: seller ? seller.id : l.sellerId, to: j ? j.id : 'jpot', amount: fee, listingId: l.id, title: l.title, memo: '販売手数料', pending: true });
            bump();
            saveLocal(true);
            renderAll();
        }

        function deleteListing(listingId) {
            const me = currentUser();
            if (!me) {
                toast('ログインが必要');
                return;
            }
            const idx = state.listings.findIndex(x => x.id === listingId);
            if (idx < 0) {
                toast('出品が見つかりません');
                return;
            }
            const l = state.listings[idx];
            if (l.sellerId !== me.id) {
                toast('自分の出品のみ削除可');
                return;
            }
            if ((l.sold || 0) > 0) {
                toast('購入履歴があるため削除不可');
                return;
            }
            const operation = createOperation('delete_listing', { listingId });
            queueOperation(operation);
            state.listings.splice(idx, 1);
            bump();
            saveLocal(true);
            renderAll();
        }

        function toggleListingActive(listingId) {
            const me = currentUser();
            if (!me) {
                toast('ログインが必要');
                return;
            }
            const l = state.listings.find(x => x.id === listingId);
            if (!l) {
                toast('出品が見つかりません');
                return;
            }
            if (l.sellerId !== me.id) {
                toast('自分の出品のみ');
                return;
            }
            const operation = createOperation('toggle_listing', { listingId });
            queueOperation(operation);
            l.active = !l.active;
            bump();
            saveLocal(true);
            renderAll();
        }

        function buyerReturn(rightId) {
            const me = currentUser();
            if (!me) {
                toast('ログインが必要');
                return;
            }
            const r = state.rights.find(x => x.id === rightId);
            if (!r) return;
            if (r.buyerId !== me.id || r.status !== 'owned') {
                toast('保有中のみ返品可');
                return;
            }
            const l = state.listings.find(x => x.id === r.listingId);
            const seller = findUserById(r.sellerId);
            const refund = Math.floor(l.price * 0.90);
            if (seller.balance < refund) {
                toast('販売者の残高不足');
                return;
            }
            seller.balance -= refund;
            const buyer = findUserById(r.buyerId);
            buyer.balance += refund;
            l.sold = Math.max(0, (l.sold || 0) - 1);
            if (l.sold < l.qty) {
                l.active = true;
            }
            state.rights = state.rights.filter(x => x.id !== rightId);
            addTx({
                type: 'return',
                from: seller.id,
                to: buyer.id,
                listingId: l.id,
                title: r.title,
                amount: refund,
                memo: '購入者が返品（手数料は返らない）'
            });
            bump();
            saveLocal();
            renderAll();
        }

        function buyerRequest(rightId) {
            const me = currentUser();
            if (!me) {
                toast('ログインが必要');
                return;
            }
            const r = state.rights.find(x => x.id === rightId);
            if (!r) return;
            if (r.buyerId !== me.id || r.status !== 'owned') {
                toast('申請できません');
                return;
            }
            // optimistic
            r.status = 'request';
            addTx({ type: 'execute-request', from: r.buyerId, to: r.sellerId, listingId: r.listingId, title: r.title, memo: '実行申請', pending: true });
            bump();
            saveLocal();
            renderAll();
            const op = createOperation('buyer_request', { rightId });
            queueOperation(op);
        }

        function sellerRespond(rightId, action) {
            const me = currentUser();
            if (!me) { toast('ログインが必要'); return; }
            const r = state.rights.find(x => x.id === rightId);
            if (!r) return;
            if (r.sellerId !== me.id || r.status !== 'request') { toast('対象外'); return; }
            const l = state.listings.find(x => x.id === r.listingId);
            // optimistic
            if (action === 'exec') {
                r.status = 'seller_executed';
                addTx({ type: 'execute-done', from: r.sellerId, to: r.buyerId, listingId: r.listingId, title: r.title, memo: '販売者が実行', pending: true });
            } else {
                const seller = findUserById(r.sellerId);
                if (seller.balance < l.price) { toast('残額不足'); return; }
                r.status = 'seller_cancel_requested';
                addTx({ type: 'execute-cancel-ask', from: r.sellerId, to: r.buyerId, listingId: r.listingId, title: r.title, memo: '販売者がキャンセル申請', pending: true });
            }
            bump(); saveLocal(); renderAll();
            const op = createOperation('seller_respond', { rightId, action });
            queueOperation(op);
        }

        function buyerFinalize(rightId) {
            const me = currentUser();
            if (!me) { toast('ログインが必要'); return; }
            const r = state.rights.find(x => x.id === rightId);
            if (!r) return; if (r.buyerId !== me.id) { toast('あなたは購入者ではありません'); return; }
            const l = state.listings.find(x => x.id === r.listingId);
            // optimistic
            if (r.status === 'seller_executed') {
                r.status = 'finalized'; r.executed = true;
                addTx({ type: 'execute-finalize', from: r.buyerId, to: r.sellerId, listingId: r.listingId, title: r.title, memo: '購入者が実行確認（確定）', pending: true });
            } else if (r.status === 'seller_cancel_requested') {
                const seller = findUserById(r.sellerId); const buyer = findUserById(r.buyerId);
                if (seller.balance < l.price) { toast('販売者の残高不足'); return; }
                seller.balance -= l.price; buyer.balance += l.price; l.sold = Math.max(0, (l.sold || 0) - 1);
                if (l.sold < l.qty) l.active = true;
                state.rights = state.rights.filter(x => x.id !== rightId);
                addTx({ type: 'execute-cancel-ok', from: r.buyerId, to: r.sellerId, listingId: r.listingId, title: r.title, amount: l.price, memo: 'キャンセル返金（全額）確定', pending: true });
            } else { toast('確定不可の状態'); return; }
            bump(); saveLocal(); renderAll();
            const op = createOperation('buyer_finalize', { rightId });
            queueOperation(op);
        }

        const MORNING_HOUR = 7, MORNING_MINUTE = 30, MORNING_BASE = 1000, STREAK_MAX = 30, STREAK_INC = 100;

        function todayKey() {
            const d = new Date();
            const y = d.getFullYear(), m = String(d.getMonth() + 1).padStart(2, '0'),
                day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`;
        }

        function beforeDeadline() {
            const n = new Date();
            if (n.getHours() < MORNING_HOUR) return true;
            if (n.getHours() > MORNING_HOUR) return false;
            return n.getMinutes() <= MORNING_MINUTE;
        }

        function canClaimMorning() {
            const me = currentUser();
            if (!me) return {ok: false, reason: 'ログインしてください'};
            if (isJackpot(me)) return {ok: false, reason: 'ジャックポットは朝活対象外'};
            const t = todayKey();
            if (me.lastMorningDate === t) return {ok: false, reason: '本日は受取済み'};
            if (!beforeDeadline()) return {ok: false, reason: '7:30を過ぎています'};
            return {ok: true};
        }

        function updateMorningButton() {
            const me = currentUser();
            const s = canClaimMorning();
            els.morningBtn.disabled = !s.ok;
            const cnt = me ? (me.streakCount || 0) : 0;
            els.streakBadge.textContent = '🔥' + cnt;
        }

        function morningClaim() {
            const me = currentUser();
            const c = canClaimMorning();
            if (!c.ok) {
                toast(c.reason);
                updateMorningButton();
                return;
            }
            const today = todayKey();
            if (me.lastMorningDate) {
                const diff = Math.round((new Date(today) - new Date(me.lastMorningDate)) / 86400000);
                me.streakCount = (diff === 1) ? Math.min((me.streakCount || 0) + 1, STREAK_MAX) : 1;
            } else {
                me.streakCount = 1;
            }
            me.lastMorningDate = today;
            const bonus = MORNING_BASE + STREAK_INC * (me.streakCount || 0);
            me.balance += bonus;
            addTx({type: 'mint', to: me.id, amount: bonus, memo: `朝活（連続${me.streakCount}日）`});
            bump();
            saveLocal();
            renderAll();
        }

        function renderJackpot() {
            const j = jackpotUser();
            const bal = j ? j.balance : 0;
            document.getElementById('jackpotChip').textContent = '現在: ' + fmt.format(bal) + ' coin';
            els.jackpotBadge.textContent = 'JPOT: ' + fmt.format(bal);
            const me = currentUser();
            els.rouletteBtn.disabled = !me || (me && me.balance < 100) || bal <= 0 || (me && isJackpot(me));
        }

        function rouletteSpin() {
            const me = currentUser();
            if (!me) {
                toast('ログインが必要');
                return;
            }
            if (isJackpot(me)) {
                toast('ジャックポットでは遊べません');
                return;
            }
            if (me.balance < 100) {
                toast('残高不足');
                return;
            }
            const j = jackpotUser();
            if (!j) {
                toast('JPOTユーザーが見つかりません');
                return;
            }
            if (j.balance <= 0) {
                toast('ジャックポットが空です');
                return;
            }
            me.balance -= 100;
            j.balance += 100;
            addTx({type: 'jpot-fee', from: me.id, to: j.id, amount: 100, memo: 'ルーレット参加費'});
            const roll = Math.random();
            if (roll < 0.01) {
                const payout = j.balance;
                if (payout > 0) {
                    me.balance += payout;
                    addTx({type: 'jackpot', from: j.id, to: me.id, amount: payout, memo: '🎉 ジャックポット当選'});
                    j.balance = 0;
                    document.getElementById('rouletteResult').textContent = '結果: JACKPOT!! +' + fmt.format(payout) + ' coin';
                } else {
                    document.getElementById('rouletteResult').textContent = '結果: JACKPOT 0';
                }
                bump();
                saveLocal();
                renderAll();
                return;
            }
            const prizes = [{p: 0.40, v: 0}, {p: 0.25, v: 50}, {p: 0.18, v: 100}, {p: 0.09, v: 150}, {
                p: 0.05,
                v: 200
            }, {p: 0.02, v: 400}, {p: 0.0099, v: 700}];
            let r = Math.random(), acc = 0, val = 0;
            for (const it of prizes) {
                acc += it.p;
                if (r < acc) {
                    val = it.v;
                    break;
                }
            }
            const payout = Math.min(j.balance, val);
            if (payout > 0) {
                me.balance += payout;
                j.balance -= payout;
                addTx({type: 'roulette', from: j.id, to: me.id, amount: payout, memo: 'ルーレット払い出し'});
            }
            document.getElementById('rouletteResult').textContent = '結果: +' + fmt.format(payout) + ' coin';
            bump();
            saveLocal();
            renderAll();
        }

        function renderSummary() {
            els.kpiMembers.textContent = state.users.filter(u => !isJackpot(u)).length;
            els.kpiSupply.textContent = coins(state.users.reduce((s, u) => s + (u.balance || 0), 0));
            const last = state.txs[0];
            els.lastActivity.textContent = last ? '最終更新：' + ts2str(last.ts) : '最終更新：—';
        }

        function renderWallets() {
            const list = els.walletList;
            list.innerHTML = '';
            state.users.forEach(u => {
                const row = document.createElement('div');
                row.style.cssText = 'padding:8px 10px;border:1px solid #60efff22;border-radius:10px;display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;background:#0e1836; cursor: pointer;';
                row.innerHTML = '<div style="font-weight:750">' + u.name + (u.id === state.currentUserId ? '（自分）' : '') + '</div><div class="pill">' + coins(u.balance) + '</div>';

                if (!isJackpot(u)) {
                    row.addEventListener('click', () => {
                        els.loginName.value = u.name;
                        els.loginPass.focus();
                    });
                }

                list.appendChild(row);
            });
        }

        function renderHeaderUser() {
            const me = currentUser();
            els.userBadge.textContent = me ? (me.name + ' / ' + coins(me.balance)) : '未ログイン';
            els.fromFixed.value = me ? (me.name + '（残高：' + fmt.format(me.balance) + '）') : '未ログイン';
            updateMorningButton();
            renderJackpot();

            const balanceDisplay = document.getElementById('balance-display');
            if (me && !isJackpot(me)) {
                balanceDisplay.style.display = 'flex';
                balanceDisplay.innerHTML = `<span>残高</span><strong>${coins(me.balance)}</strong>`;
            } else {
                balanceDisplay.style.display = 'none';
            }
        }

        function renderSelects() {
            const me = currentUser();
            let list = state.users.filter(u => !me || u.id !== me.id);
            if (me && !isJackpot(me)) list = list.filter(u => !isJackpot(u));
            els.toSelect.innerHTML = '<option value="">選択</option>' + list.map(u => '<option value="' + u.id + '">' + u.name + '（' + fmt.format(u.balance) + '）</option>').join('');
            els.memberFilter.innerHTML = '<option value="">すべて</option>' + state.users.map(u => '<option value="' + u.id + '">' + u.name + '</option>').join('');
        }

        function renderHistory() {
            const q = (els.searchInput.value || '').toLowerCase();
            const f = els.memberFilter.value || '';
            els.historyBody.innerHTML = '';
            const frag = document.createDocumentFragment();
            state.txs.filter(t => {
                if (f && !((t.from && t.from === f) || (t.to && t.to === f) || (t.actedBy && t.actedBy === f))) return false;
                if (!q) return true;
                const text = ((t.memo || '') + ' ' + (t.title || '')).toLowerCase();
                return text.includes(q);
            }).forEach(t => {
                const tr = document.createElement('tr');
                const c = x => {
                    const td = document.createElement('td');
                    td.innerHTML = x;
                    return td;
                };
                tr.append(c(ts2str(t.ts)), c(typeLabel(t.type)), c('<span class="pill">' + (nameOf(t.from) || '—') + '</span>'), c('<span class="pill">' + (nameOf(t.to) || '—') + '</span>'), c(t.title ? (t.title + (t.memo ? (' / ' + t.memo) : '')) : (t.memo || '')), c('<span>' + (t.amount ? fmt.format(t.amount) : '') + '</span>'));
                frag.appendChild(tr);
            });
            els.historyBody.appendChild(frag);
        }

        function typeLabel(tp) {
            return tp === 'transfer' ? '送金' : tp === 'purchase' ? '購入' : tp === 'execute-request' ? '実行申請' : tp === 'execute-done' ? '実行（販売者）' : tp === 'execute-finalize' ? '実行確定（購入者）' : tp === 'execute-cancel-ask' ? 'キャンセル申請（販売者）' : tp === 'execute-cancel-ok' ? 'キャンセル確定（購入者）' : tp === 'return' ? '返品' : tp === 'mint' ? '発行' : tp === 'fee' ? '手数料' : tp === 'roulette' ? 'ルーレット' : tp === 'jackpot' ? 'ジャックポット' : tp === 'jpot-fee' ? 'JPOT入金' : '—';
        }

        function renderListings() {
            els.listingBody.innerHTML = '';
            const me = currentUser();
            state.listings.forEach(l => {
                const remaining = (l.qty || 1) - (l.sold || 0);
                const tr = document.createElement('tr');

                function td(text) {
                    const x = document.createElement('td');
                    x.textContent = text;
                    return x;
                }

                tr.append(td(l.title + (l.active ? '' : '（停止中）')), (function () {
                    const x = document.createElement('td');
                    x.innerHTML = '<b>' + fmt.format(l.price) + '</b>';
                    return x;
                })(), td(remaining + '/' + l.qty), td(nameOf(l.sellerId)), td(l.desc || ''));
                const tdA = document.createElement('td');
                if (me) {
                    if (l.sellerId === me.id) {
                        const tog = document.createElement('button');
                        tog.className = 'btn secondary';
                        tog.textContent = l.active ? '停止' : '公開';
                        tog.onclick = () => toggleListingActive(l.id);
                        const del = document.createElement('button');
                        del.className = 'btn secondary';
                        del.textContent = '削除';
                        del.disabled = (l.sold || 0) > 0;
                        del.onclick = () => deleteListing(l.id);
                        tdA.append(tog, document.createTextNode(' '), del);
                    } else {
                        const buy = document.createElement('button');
                        buy.className = 'btn';
                        buy.textContent = '購入';
                        buy.disabled = !l.active || remaining <= 0 || (me && isJackpot(me));
                        buy.onclick = () => {
                            buy.disabled = true;
                            buyListing(l.id);
                        };
                        tdA.appendChild(buy);
                    }
                } else {
                    const s = document.createElement('span');
                    s.className = 'chip';
                    s.textContent = 'ログインしてください';
                    tdA.appendChild(s);
                }
                tr.appendChild(tdA);
                els.listingBody.appendChild(tr);
            });
        }

        function renderRights() {
            els.rightsBody.innerHTML = '';
            const me = currentUser();
            if (!me) return;
            // Purchaser's rights
            state.rights.filter(r => r.buyerId === me.id).forEach(r => {
                const tr = document.createElement('tr');

                function td(t) {
                    const x = document.createElement('td');
                    x.textContent = t;
                    return x;
                }

                tr.append(td(ts2str(r.ts)), td(r.title), td(nameOf(r.sellerId)), td(statusLabel(r)));
                const tdA = document.createElement('td');
                tdA.appendChild(rightActionButtons(r));
                tr.appendChild(tdA);
                els.rightsBody.appendChild(tr);
            });

            // Seller's view: list rights where current user is seller
            const sellerSection = document.getElementById('sellerRightsSection');
            if (sellerSection) {
                sellerSection.innerHTML = '';
                state.rights.filter(r => r.sellerId === me.id).sort((a,b) => (a.status=== 'owned'?1:0) - (b.status==='owned'?1:0) || (a.ts||0)-(b.ts||0)).forEach(r => {
                    const div = document.createElement('div');
                    div.className = 'seller-right' + (r.status !== 'finalized' ? ' pending-right' : ' done-right');
                    div.style.padding = '8px';
                    div.style.borderBottom = '1px solid rgba(255,255,255,.04)';
                    const left = document.createElement('div');
                    left.textContent = `${ts2str(r.ts)} ${r.title} （購入者: ${nameOf(r.buyerId)}）`;
                    const btns = document.createElement('div');
                    btns.style.marginTop = '6px';
                    if (r.status === 'request') {
                        const rep = document.createElement('button'); rep.className = 'btn'; rep.textContent = '実行完了を報告'; rep.onclick = () => { rep.disabled = true; const op = createOperation('report_execution', { rightId: r.id }); queueOperation(op); };
                        btns.appendChild(rep);
                    } else if (r.status === 'buyer_rejected') {
                        const info = document.createElement('span'); info.className = 'chip'; info.textContent = '購入者により拒否済み'; info.style.fontWeight = '800'; info.style.color = '#ff8080'; btns.appendChild(info);
                        // allow seller to perform a refund after rejection
                        const refundBtn = document.createElement('button'); refundBtn.className = 'btn secondary'; refundBtn.textContent = '返金する';
                        refundBtn.onclick = () => {
                            // show simple inline prompt for amount
                            const amt = prompt('返金金額を入力してください（空欄で全額）：', '');
                            let num = null;
                            if (amt !== null && amt.trim() !== '') {
                                num = parseInt(amt.replace(/[^0-9]/g, ''), 10);
                                if (isNaN(num) || num <= 0) { toast('無効な金額です'); return; }
                            }
                            refundBtn.disabled = true;
                            const payload = { rightId: r.id };
                            if (typeof num === 'number') payload.amount = num;
                            const op = createOperation('seller_refund', payload);
                            queueOperation(op);
                            toast('返金リクエストを送信しました');
                        };
                        btns.appendChild(document.createTextNode(' ')); btns.appendChild(refundBtn);
                    } else if (r.status === 'finalized') {
                        const info = document.createElement('span'); info.className = 'chip'; info.textContent = '完了済'; btns.appendChild(info);
                    }
                    div.appendChild(left); div.appendChild(btns); sellerSection.appendChild(div);
                });
            }
        }

        function statusLabel(r) {
            return r.status === 'owned' ? '保有中' : r.status === 'request' ? '販売者の対応待ち' : r.status === 'seller_executed' ? '販売者が実行済（確認待ち）' : r.status === 'seller_cancel_requested' ? '販売者がキャンセル申請（確認待ち）' : r.status === 'finalized' ? (r.executed ? '確定（実行済）' : '確定（キャンセル）') : '—';
        }

        function rightActionButtons(r) {
            const span = document.createElement('span');
                if (r.status === 'owned') {
                const btn = document.createElement('button');
                btn.className = 'btn';
                btn.textContent = '実行を申請';
                btn.onclick = () => {
                    btn.disabled = true;
                    buyerRequest(r.id);
                };
                const ret = document.createElement('button');
                ret.className = 'btn secondary';
                ret.textContent = '返品';
                ret.onclick = () => {
                    ret.disabled = true;
                    buyerReturn(r.id);
                };
                span.append(btn, document.createTextNode(' '), ret);
            } else if (r.status === 'seller_executed' || r.status === 'seller_reported') {
                // When seller reported execution, buyer can confirm or reject (reject allowed once)
                const confirmBtn = document.createElement('button'); confirmBtn.className = 'btn'; confirmBtn.textContent = '承認（確認）'; confirmBtn.onclick = () => { confirmBtn.disabled = true; const op = createOperation('buyer_confirm', { rightId: r.id }); queueOperation(op); };
                const rejectBtn = document.createElement('button'); rejectBtn.className = 'btn secondary'; rejectBtn.textContent = '拒否（1回）';
                // disable if already rejected according to server-side counter
                if (r.rejectionCount && r.rejectionCount >= 1) {
                    rejectBtn.disabled = true;
                    rejectBtn.title = '既に拒否済みです';
                } else {
                    rejectBtn.onclick = () => { rejectBtn.disabled = true; const op = createOperation('buyer_reject', { rightId: r.id }); queueOperation(op); };
                }
                span.append(confirmBtn, document.createTextNode(' '), rejectBtn);
            } else if (r.status === 'seller_cancel_requested') {
                const btn = document.createElement('button');
                btn.className = 'btn secondary';
                btn.textContent = 'キャンセル承認（確定）';
                btn.onclick = () => {
                    btn.disabled = true;
                    buyerFinalize(r.id);
                };
                span.appendChild(btn);
            } else {
                const chip = document.createElement('span');
                chip.className = 'chip';
                chip.textContent = '操作なし';
                span.appendChild(chip);
            }
            return span;
        }

        function switchMarketSub(which) {
            document.querySelectorAll('#tab-market .tab').forEach(s => s.classList.toggle('active', s.dataset.sub === which));
            els.marketSell.style.display = which === 'sell' ? 'block' : 'none';
            els.marketList.style.display = which === 'list' ? 'block' : 'none';
        }

        function renderTabs() {
            const show = name => {
                els.tabTransfer.style.display = name === 'transfer' ? 'block' : 'none';
                els.tabMarket.style.display = name === 'market' ? 'block' : 'none';
                els.tabMyRights.style.display = name === 'myrights' ? 'block' : 'none';
                els.tabGamble.style.display = name === 'gamble' ? 'block' : 'none';
            };
            const active = document.querySelector('.card .hd .tabbar .tab.active');
            show(active ? active.dataset.tab : 'transfer');
        }

        function renderAll() {
            renderSummary();
            renderWallets();
            renderHeaderUser();
            renderSelects();
            renderHistory();
            renderListings();
            renderRights();
            renderTabs();
        }

        els.registerBtn.addEventListener('click', () => register(els.regName.value, els.regPass.value));
        els.loginBtn.addEventListener('click', () => login(els.loginName.value, els.loginPass.value));
        els.logoutBtn.addEventListener('click', logout);
        els.sendBtn.addEventListener('click', () => {
            transfer(els.toSelect.value, els.amountInput.value, els.memoInput.value);
            els.amountInput.value = '';
            els.memoInput.value = '';
        });
        els.searchInput.addEventListener('input', renderHistory);
        els.memberFilter.addEventListener('change', renderHistory);
        // Server-side export/import
        async function fetchExport() {
            if (!syncSettings.url || !syncSettings.room || !syncSettings.key) {
                toast('同期設定が必要です');
                return;
            }
            try {
                const u = new URL(syncSettings.url.replace(/\/state$/, '') + '/export');
                u.searchParams.set('room', syncSettings.room);
                u.searchParams.set('key', syncSettings.key);
                const res = await fetch(u.toString(), { method: 'POST' });
                if (!res.ok) { toast('エクスポート失敗'); return; }
                const data = await res.json();
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `trpg_export_${syncSettings.room}_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(a.href);
                toast('エクスポート完了');
            } catch (e) {
                console.error('export failed', e);
                toast('エクスポート失敗');
            }
        }

        async function fetchImport(file) {
            if (!syncSettings.url || !syncSettings.room || !syncSettings.key) {
                toast('同期設定が必要です');
                return;
            }
            try {
                const txt = await file.text();
                const jsonData = JSON.parse(txt);
                if (!confirm(`部屋「${syncSettings.room}」を上書きしてインポートしますか？`)) return;
                const u = new URL(syncSettings.url.replace(/\/state$/, '') + '/import');
                u.searchParams.set('room', syncSettings.room);
                u.searchParams.set('key', syncSettings.key);
                const res = await fetch(u.toString(), { method: 'POST', headers: {'content-type':'application/json'}, body: JSON.stringify({ data: jsonData, overwrite: true }) });
                if (!res.ok) { toast('インポート失敗'); return; }
                const result = await res.json();
                if (result && result.ok) {
                    toast('インポート完了');
                    // fetch latest state
                    await kvFetchLatest();
                } else {
                    toast('インポート失敗');
                }
            } catch (e) {
                console.error('import failed', e);
                toast('インポート失敗');
            }
        }

        els.exportBtn.addEventListener('click', () => fetchExport());
        els.importFile.addEventListener('change', e => {
            const f = e.target.files[0];
            if (!f) return;
            fetchImport(f);
            e.target.value = '';
        });
        document.querySelectorAll('.card .hd .tabbar .tab').forEach(t => t.addEventListener('click', () => {
            document.querySelectorAll('.card .hd .tabbar .tab').forEach(x => x.classList.remove('active'));
            t.classList.add('active');
            renderTabs();
        }));
        els.subtabs.forEach(s => s.addEventListener('click', () => switchMarketSub(s.dataset.sub)));
        els.createListingBtn.addEventListener('click', () => {
          createListing(els.listTitle.value, els.listPrice.value, els.listDesc.value);
        });

        els.morningBtn.addEventListener('click', morningClaim);
        els.rouletteBtn.addEventListener('click', rouletteSpin);
        els.btnConnect.addEventListener('click', () => {
            saveSyncSettings();
            // toggle queue-based KV sync
            if (pushTimer || fetchTimer) {
                if (pushTimer) { clearInterval(pushTimer); pushTimer = null; }
                if (fetchTimer) { clearInterval(fetchTimer); fetchTimer = null; }
                els.syncStatus.textContent = '停止中';
                toast('同期を停止しました');
            } else {
                if (syncSettings.url && syncSettings.room && syncSettings.key) {
                    // start periodic push + fetch loop
                    // push pending ops every 2s, fetch latest every 3s
                    kvFetchLatest();
                    if (pushTimer) clearInterval(pushTimer);
                    if (fetchTimer) clearInterval(fetchTimer);
                    pushTimer = setInterval(() => {
                        kvPushState().catch(e => console.error('kvPushState err', e));
                    }, 2000);
                    fetchTimer = setInterval(() => {
                        kvFetchLatest().catch(e => console.error('kvFetchLatest err', e));
                    }, 3000);
                    els.syncStatus.textContent = '同期中';
                    toast('同期を開始しました');
                } else {
                    toast('同期設定を入力してください');
                }
            }
        });

        // Adjust table max-heights so card tables can grow to match left column but still scroll beyond that
        function adjustCardTableHeights() {
            try {
                const grid = document.querySelector('.grid');
                if (!grid) return;
                const leftCard = grid.querySelector('section.card'); // first card in grid (left column)
                if (!leftCard) return;
                const leftRect = leftCard.getBoundingClientRect();
                // compute available height relative to viewport, allow a small padding
                const available = Math.max(200, leftRect.height - 24);
                // center panel should scroll earlier so give it slightly less height
                document.querySelectorAll('.grid section.card').forEach((card, idx) => {
                    const t = card.querySelector('.bd .table');
                    if (!t) return;
                    if (idx === 1) {
                        // center panel - slightly shorter to force earlier scroll
                        t.style.maxHeight = Math.max(160, available - 80) + 'px';
                    } else {
                        t.style.maxHeight = available + 'px';
                    }
                });
                // make history table container allow slightly wider content
                const historyTbl = document.querySelector('#tab-history .table') || document.querySelector('#tab-market .table') || document.querySelector('.grid section.card:nth-child(3) .bd .table');
                if (historyTbl) historyTbl.style.minWidth = '320px';
            } catch (e) {
                console.warn('adjustCardTableHeights error', e);
            }
        }

        // run on load, resize, and after each render to keep heights in sync
        window.addEventListener('load', adjustCardTableHeights);
        window.addEventListener('resize', () => { setTimeout(adjustCardTableHeights, 80); });
        // call after renderAll to react to dynamic content changes
        const origRenderAll = renderAll;
        renderAll = function() { origRenderAll(); adjustCardTableHeights(); };
        els.btnSyncNow.addEventListener('click', async () => {
            try {
                await kvPushState();
            } catch (e) { console.error('manual push err', e); }
            try {
                await kvFetchLatest();
            } catch (e) { console.error('manual fetch err', e); }
        });
        loadLocal();
        ensureJackpotUser();
        // compact log toggle init
        try {
            const compactKey = 'trpg_log_compact_v1';
            const btn = document.getElementById('compactLogBtn');
            const rightCard = document.querySelectorAll('.grid section.card')[2];
            const applyCompact = (on) => {
                if (!rightCard) return;
                if (on) rightCard.classList.add('compact'); else rightCard.classList.remove('compact');
                setTimeout(adjustCardTableHeights, 60);
            };
            if (btn) {
                const cur = localStorage.getItem(compactKey) === '1';
                applyCompact(cur);
                btn.textContent = cur ? 'ログ: 標準表示' : 'ログ: コンパクト';
                btn.addEventListener('click', () => {
                    const now = localStorage.getItem(compactKey) === '1';
                    localStorage.setItem(compactKey, now ? '0' : '1');
                    applyCompact(!now);
                    btn.textContent = !now ? 'ログ: 標準表示' : 'ログ: コンパクト';
                    toast('ログ表示を切替ました');
                });
            }
        } catch (e) { console.warn('compact init failed', e); }
        // Wallet expand/collapse
        try {
            const walletBtn = document.getElementById('walletToggleBtn');
            const walletList = document.getElementById('walletList');
            const WALLET_KEY = 'trpg_wallet_collapsed_v1';
            if (walletBtn && walletList) {
                const collapsed = localStorage.getItem(WALLET_KEY) === '1';
                walletList.style.display = collapsed ? 'none' : 'grid';
                walletBtn.textContent = collapsed ? '展開' : '折りたたむ';
                walletBtn.addEventListener('click', () => {
                    const now = localStorage.getItem(WALLET_KEY) === '1';
                    localStorage.setItem(WALLET_KEY, now ? '0' : '1');
                    walletList.style.display = now ? 'grid' : 'none';
                    walletBtn.textContent = now ? '折りたたむ' : '展開';
                    setTimeout(adjustCardTableHeights, 60);
                });
            }
        } catch (e) { console.warn('wallet toggle init failed', e); }

        // Observe mutations in key regions to reflow heights automatically
        try {
            const observeTargets = [document.getElementById('walletList'), document.getElementById('listingBody'), document.getElementById('historyBody'), document.getElementById('rightsBody'), document.getElementById('sellerRightsSection')].filter(Boolean);
            if (observeTargets.length) {
                const mo = new MutationObserver((mutations) => {
                    // Debounce
                    if (window.__adjustTimeout) clearTimeout(window.__adjustTimeout);
                    window.__adjustTimeout = setTimeout(() => { adjustCardTableHeights(); }, 80);
                });
                for (const t of observeTargets) mo.observe(t, { childList: true, subtree: true, characterData: true });
            }
        } catch (e) { console.warn('mutation observer init failed', e); }
        state.listings.forEach(l => {
            if (typeof l.qty !== 'number') l.qty = 1;
            if (typeof l.sold !== 'number') l.sold = 0;
        });
        state.rights.forEach(r => {
            if (!r.status) {
                r.status = r.executed ? 'finalized' : 'owned';
            }
        });
        loadSyncSettings();
        renderAll();
        if (state.users.filter(u => !isJackpot(u)).length === 0) {
            toast('まずは新規登録してください（初期 10,000 coin） / ジャックポットは誰でもログイン可');
        }

        // Auto-connect if settings are available
        if (syncSettings.url && syncSettings.room && syncSettings.key) {
            els.btnConnect.click();
            toast('以前の設定で自動的に同期を開始します...');
        }

        function jackpotUserInitFix() {
            if (typeof state.jackpot === 'number') {
                jackpotUser().balance += state.jackpot;
                delete state.jackpot;
            }
        }

        jackpotUserInitFix();

        window.addEventListener('keydown', (e) => {
            // Use 'o' or 'O' to be safe
            if (e.ctrlKey && e.shiftKey && (e.key === 'O' || e.key === 'o')) {
                e.preventDefault();
                const command = prompt('コマンドを入力してください:');
                if (command === 'devmode') {
                    window.location.href = 'test.html';
                }
            }
        });
    })();
</script>
<div id="balance-display" style="display: none;"></div>
<div id="emphasis-modal" style="display: none;">
    <div id="emphasis-modal-content"></div>
</div>
</body>
</html>
